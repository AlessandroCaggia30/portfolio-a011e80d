<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindNotes</title>
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <style>
/* MindNotes - All Styles Inlined */
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
    --bg: #0d0d12;
    --bg2: #16161f;
    --bg3: #1e1e2a;
    --border: #2a2a3a;
    --text: #e8e8f0;
    --text2: #777788;
    --accent: #6c5ce7;
    --accent2: #a29bfe;
    --green: #00b894;
    --orange: #fdcb6e;
    --red: #e74c3c;
    --blue: #74b9ff;
}

[data-theme="light"] {
    --bg: #f5f5f7;
    --bg2: #ffffff;
    --bg3: #eeeef0;
    --border: #e0e0e5;
    --text: #1a1a2e;
    --text2: #6b6b80;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
}

.app { display: flex; height: 100vh; }

.sidebar {
    width: 360px;
    background: var(--bg2);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    transition: width 0.3s ease, margin-left 0.3s ease;
    position: relative;
}

.sidebar.collapsed {
    width: 0;
    margin-left: -1px;
    overflow: hidden;
}

.sidebar-toggle {
    position: fixed;
    top: 50%;
    left: 346px;
    transform: translateY(-50%);
    width: 28px;
    height: 28px;
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: var(--text2);
    z-index: 1000;
    transition: all 0.3s;
}

.sidebar-toggle:hover {
    background: var(--accent);
    color: var(--text);
    border-color: var(--accent);
}

.sidebar-toggle.collapsed { left: 10px; }

.sidebar-header {
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
    font-size: 18px;
    font-weight: 700;
    letter-spacing: -0.02em;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.sidebar-header span { color: var(--text); }

.header-actions {
    display: flex;
    gap: 8px;
}

.theme-toggle, .sync-btn {
    width: 32px;
    height: 32px;
    background: var(--bg3);
    border: 1px solid var(--border);
    color: var(--text2);
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
}

.theme-toggle:hover, .sync-btn:hover {
    background: var(--accent);
    color: var(--text);
    border-color: var(--accent);
}

.sync-btn.synced { color: var(--green); }
.sync-btn.syncing { animation: spin 1s linear infinite; }

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.nav-tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
    padding: 4px;
    gap: 4px;
}

.nav-tab {
    flex: 1;
    padding: 10px 8px;
    background: transparent;
    border: none;
    color: var(--text2);
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    transition: all 0.15s;
    border-radius: 8px;
}

.nav-tab:hover { background: var(--bg3); color: var(--text); }
.nav-tab.active { background: rgba(108, 92, 231, 0.15); color: var(--accent); }
.nav-tab .icon { font-size: 18px; }

.nav-tab .badge {
    background: var(--orange);
    color: #000;
    padding: 1px 6px;
    border-radius: 8px;
    font-size: 10px;
    font-weight: 600;
}

.search-bar {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
}

.search-input {
    width: 100%;
    padding: 10px 14px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 10px;
    color: var(--text);
    font-size: 13px;
    transition: all 0.2s;
}

.search-input:focus {
    outline: none;
    border-color: var(--accent);
    background: var(--bg);
}

.search-input::placeholder { color: var(--text2); }

.search-results {
    max-height: 300px;
    overflow-y: auto;
    display: none;
}

.search-results.active { display: block; }

.search-result {
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border);
}

.search-result:hover { background: var(--bg3); }
.search-result .title { font-weight: 500; font-size: 13px; }
.search-result .path { font-size: 11px; color: var(--text2); margin-top: 2px; }
.search-result .snippet { font-size: 11px; color: var(--text2); margin-top: 4px; }
.search-result .snippet mark { background: var(--orange); color: #000; padding: 0 2px; border-radius: 2px; }

.hl-yellow { background: #ffeaa7; color: #000; padding: 1px 3px; border-radius: 2px; }
.hl-green { background: #55efc4; color: #000; padding: 1px 3px; border-radius: 2px; }
.hl-pink { background: #fd79a8; color: #000; padding: 1px 3px; border-radius: 2px; }

mark { background: #ffeaa7; color: #000; padding: 1px 3px; border-radius: 2px; }

.obsidian-math {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 12px 16px;
    margin: 8px 0;
    font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
    font-size: 13px;
    white-space: pre-wrap;
    overflow-x: auto;
    color: var(--text);
}

.obsidian-inline-math {
    background: rgba(108, 92, 231, 0.15);
    color: var(--accent);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
    font-size: 13px;
}

.topics-section {
    flex: 1;
    overflow-y: auto;
    padding: 8px 0;
}

.topic-group { margin-bottom: 4px; }

.topic-header {
    padding: 10px 20px;
    margin: 0 8px;
    font-size: 12px;
    font-weight: 600;
    color: var(--text2);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    border-radius: 8px;
    transition: all 0.15s;
}

.topic-header:hover { background: var(--bg3); color: var(--text); }
.topic-header .arrow { font-size: 10px; transition: transform 0.2s; opacity: 0.5; }
.topic-header.expanded .arrow { transform: rotate(90deg); }
.topic-header .name { flex: 1; }

.topic-actions {
    opacity: 0;
    display: flex;
    gap: 4px;
}

.topic-header:hover .topic-actions { opacity: 1; }

.topic-actions button {
    background: none;
    border: none;
    color: var(--text2);
    cursor: pointer;
    font-size: 14px;
    padding: 2px 5px;
    border-radius: 4px;
}

.topic-actions button:hover { color: var(--accent); background: rgba(108,92,231,0.2); }
.topic-actions .delete-topic-btn:hover { color: #e74c3c; background: rgba(231,76,60,0.2); }

.subtopics { display: none; padding: 4px 0; }
.topic-group.expanded .subtopics { display: block; }

.subtopic-item {
    padding: 10px 20px 10px 40px;
    margin: 2px 8px;
    font-size: 13px;
    font-weight: 500;
    color: var(--text);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    border-radius: 8px;
    transition: all 0.15s;
}

.subtopic-item:hover { background: var(--bg3); }

.subtopic-item.active {
    background: linear-gradient(135deg, rgba(108,92,231,0.3), rgba(108,92,231,0.15));
    color: var(--text);
}

.subtopic-item .count {
    margin-left: auto;
    font-size: 11px;
    color: var(--text2);
    background: var(--bg3);
    padding: 2px 8px;
    border-radius: 10px;
    font-weight: 500;
}

.subtopic-item.active .count { background: rgba(108,92,231,0.2); }

.subtopic-item .delete-subtopic-btn {
    opacity: 0;
    background: none;
    border: none;
    color: var(--text2);
    cursor: pointer;
    font-size: 14px;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 4px;
    transition: opacity 0.15s, color 0.15s, background 0.15s;
}
.subtopic-item:hover .delete-subtopic-btn { opacity: 1; }
.subtopic-item .delete-subtopic-btn:hover { color: #e74c3c; background: rgba(231,76,60,0.2); }

.add-btn {
    margin: 12px 16px;
    padding: 12px;
    background: transparent;
    border: 1px dashed var(--border);
    color: var(--text2);
    border-radius: 10px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s;
}

.add-btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(108,92,231,0.1); }

/* Trash section in sidebar */
.trash-section {
    margin-top: auto;
    border-top: 1px solid var(--border);
    padding: 8px;
}

.trash-btn {
    width: 100%;
    padding: 12px 16px;
    background: transparent;
    border: none;
    color: var(--text2);
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 10px;
    transition: all 0.2s;
}

.trash-btn:hover { background: var(--bg3); color: var(--text); }
.trash-btn .trash-count {
    margin-left: auto;
    font-size: 11px;
    background: var(--bg3);
    padding: 2px 8px;
    border-radius: 10px;
}

/* Drag and drop for sidebar */
.topic-group.dragging, .subtopic-item.dragging {
    opacity: 0.5;
}

.topic-group.drag-over > .topic-header,
.subtopic-item.drag-over {
    background: rgba(108, 92, 231, 0.2);
    border: 1px dashed var(--accent);
}

.subtopics.drag-over {
    background: rgba(108, 92, 231, 0.1);
    border-radius: 8px;
}

/* Selection rectangle on canvas */
.selection-rect {
    position: absolute;
    border: 2px dashed var(--accent);
    background: rgba(108, 92, 231, 0.1);
    pointer-events: none;
    z-index: 1000;
}

.node.multi-selected {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.3);
}

.node.clipboard-source {
    border-style: dashed;
    opacity: 0.7;
}

/* Selection toolbar for bulk operations */
.selection-toolbar {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 8px 12px;
    display: none;
    align-items: center;
    gap: 8px;
    z-index: 1001;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
}

.selection-toolbar.visible {
    display: flex;
}

.selection-toolbar .selection-count {
    font-size: 13px;
    color: var(--text2);
    padding-right: 8px;
    border-right: 1px solid var(--border);
    margin-right: 4px;
}

.selection-toolbar button {
    padding: 8px 14px;
    background: var(--bg3);
    border: none;
    color: var(--text);
    border-radius: 8px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.15s;
}

.selection-toolbar button:hover {
    background: var(--accent);
}

.selection-toolbar button.delete-btn:hover {
    background: var(--red);
}

.selection-toolbar .move-menu {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 8px 0;
    margin-bottom: 8px;
    min-width: 200px;
    max-height: 300px;
    overflow-y: auto;
    display: none;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
}

.selection-toolbar .move-menu.visible {
    display: block;
}

.selection-toolbar .move-menu-item {
    padding: 10px 16px;
    cursor: pointer;
    font-size: 13px;
    color: var(--text);
    transition: background 0.1s;
}

.selection-toolbar .move-menu-item:hover {
    background: var(--bg3);
}

.selection-toolbar .move-menu-item.topic-header {
    font-size: 11px;
    color: var(--text2);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding: 8px 16px 4px;
    cursor: default;
}

.selection-toolbar .move-menu-item.topic-header:hover {
    background: transparent;
}

.selection-toolbar .move-menu-item.current {
    color: var(--accent);
    font-weight: 500;
}

.main { flex: 1; display: flex; position: relative; }

.canvas-wrapper {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: var(--bg);
}

.canvas-bg {
    position: absolute;
    inset: 0;
    background-image:
        linear-gradient(var(--border) 1px, transparent 1px),
        linear-gradient(90deg, var(--border) 1px, transparent 1px);
    background-size: 50px 50px;
    opacity: 0.3;
    pointer-events: none;
}

.canvas {
    position: absolute;
    width: 10000px;
    height: 10000px;
    left: -5000px;
    top: -5000px;
    cursor: grab;
}

.canvas.grabbing { cursor: grabbing; }

.canvas svg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.node {
    position: absolute;
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px 18px 20px;
    width: 160px;
    height: 80px;
    cursor: pointer;
    user-select: none;
    transition: box-shadow 0.2s ease, border-color 0.2s ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    overflow: hidden;
}

.node:hover {
    box-shadow: 0 4px 16px rgba(0,0,0,0.12);
    z-index: 10;
}

.node.selected {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.2);
}

.node.linking-source {
    border-color: var(--green);
    box-shadow: 0 0 30px rgba(0, 184, 148, 0.4), 0 0 0 2px var(--green);
}

.node.link-target {
    border-color: rgba(162, 155, 254, 0.5);
}

.node.link-target:hover {
    border-color: var(--green);
    box-shadow: 0 0 20px rgba(0, 184, 148, 0.3);
}

.node-color-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 16px;
    height: 16px;
    border-radius: 4px;
    cursor: pointer;
    transition: transform 0.15s;
    border: 1px solid rgba(0,0,0,0.15);
    opacity: 0.7;
}

.node:hover .node-color-btn { opacity: 1; }
.node-color-btn:hover { transform: scale(1.2); }

.resize-handle {
    position: absolute;
    bottom: 4px;
    right: 4px;
    width: 12px;
    height: 12px;
    cursor: nwse-resize;
    opacity: 0;
    transition: opacity 0.15s;
}

.resize-handle::before {
    content: '';
    position: absolute;
    bottom: 2px;
    right: 2px;
    width: 8px;
    height: 8px;
    border-right: 2px solid var(--text2);
    border-bottom: 2px solid var(--text2);
}

.node:hover .resize-handle { opacity: 0.5; }
.node:hover .resize-handle:hover { opacity: 1; }

.node-title {
    font-weight: 600;
    letter-spacing: -0.01em;
    color: var(--text);
    overflow: hidden;
    text-overflow: ellipsis;
    padding-right: 20px;
    word-wrap: break-word;
    line-height: 1.2;
}

.node-preview {
    font-size: 12px;
    color: var(--text2);
    margin-top: 6px;
    line-height: 1.4;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
}

.node-preview .katex { font-size: 0.9em; }
.node-preview .katex-display { margin: 4px 0; display: inline; }
.node-preview p { margin: 0; display: inline; }
.node-preview br { content: " "; }
.node-preview strong { font-weight: 700; color: var(--text); }
.node-preview em { font-style: italic; }
.node-preview code {
    background: rgba(108, 92, 231, 0.15);
    padding: 1px 4px;
    border-radius: 3px;
    font-family: monospace;
    font-size: 0.9em;
}
.node-preview .hl-yellow { background: #ffeaa7; color: #000; padding: 0 2px; border-radius: 2px; }
.node-preview .hl-green { background: #55efc4; color: #000; padding: 0 2px; border-radius: 2px; }
.node-preview .hl-pink { background: #fd79a8; color: #000; padding: 0 2px; border-radius: 2px; }

/* Inline formula editing */
.node-preview .editable-formula {
    cursor: pointer;
    border-radius: 3px;
    transition: background 0.15s;
}
.node-preview .editable-formula:hover {
    background: rgba(108, 92, 231, 0.15);
}

.formula-editor-popup {
    position: fixed;
    background: var(--bg2);
    border: 1px solid var(--accent);
    border-radius: 8px;
    padding: 12px;
    z-index: 10000;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    min-width: 280px;
    max-width: 500px;
}

.formula-editor-popup textarea {
    width: 100%;
    min-height: 60px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
    font-size: 13px;
    padding: 10px;
    resize: vertical;
}

.formula-editor-popup textarea:focus {
    outline: none;
    border-color: var(--accent);
}

.formula-editor-popup .formula-preview {
    margin-top: 10px;
    padding: 10px;
    background: var(--bg);
    border-radius: 6px;
    min-height: 40px;
    text-align: center;
}

.formula-editor-popup .formula-actions {
    display: flex;
    gap: 8px;
    margin-top: 10px;
    justify-content: flex-end;
}

.formula-editor-popup .formula-actions button {
    padding: 6px 14px;
    border-radius: 6px;
    font-size: 12px;
    cursor: pointer;
    border: none;
}

.formula-editor-popup .formula-save {
    background: var(--accent);
    color: white;
}

.formula-editor-popup .formula-cancel {
    background: var(--bg3);
    color: var(--text);
    border: 1px solid var(--border);
}

.color-picker {
    position: absolute;
    top: 24px;
    right: 0;
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px;
    display: none;
    flex-wrap: wrap;
    gap: 4px;
    width: 120px;
    z-index: 200;
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);
}

.color-picker.open { display: flex; }

.color-opt {
    width: 22px;
    height: 22px;
    border-radius: 4px;
    cursor: pointer;
    transition: transform 0.15s;
    border: 2px solid transparent;
}

.color-opt:hover { transform: scale(1.1); border-color: var(--text); }

.canvas-toolbar {
    position: absolute;
    top: 20px;
    right: 20px;
    display: flex;
    gap: 8px;
    z-index: 100;
}

.canvas-toolbar .toolbar-btn {
    padding: 10px 18px;
    background: var(--bg2);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 10px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.canvas-toolbar .toolbar-btn:hover {
    background: var(--accent);
    border-color: var(--accent);
    color: var(--text);
}

.zoom-controls {
    position: absolute;
    bottom: 20px;
    right: 20px;
    display: flex;
    gap: 4px;
    z-index: 100;
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 4px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.zoom-btn {
    width: 36px;
    height: 36px;
    background: transparent;
    border: none;
    color: var(--text2);
    border-radius: 8px;
    cursor: pointer;
    font-size: 18px;
    transition: all 0.15s;
}

.zoom-btn:hover {
    background: var(--bg3);
    color: var(--text);
}

.zoom-level {
    padding: 0 14px;
    display: flex;
    align-items: center;
    font-size: 12px;
    font-weight: 500;
    color: var(--text2);
}

.canvas-hint {
    position: absolute;
    bottom: 20px;
    left: 20px;
    font-size: 11px;
    color: var(--text2);
    z-index: 100;
    letter-spacing: 0.02em;
    opacity: 0.7;
}

.detail-panel {
    width: 0;
    background: var(--bg2);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    transition: width 0.2s;
    overflow: hidden;
}

/* View mode: larger preview panel */
.detail-panel.open.view-mode { width: 55vw; min-width: 500px; }

/* Edit mode: even larger for split view */
.detail-panel.open:not(.view-mode) { width: 80vw; min-width: 800px; }

.detail-header {
    padding: 12px 20px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 12px;
}

.detail-title-input {
    flex: 1;
    background: transparent;
    border: none;
    font-size: 18px;
    font-weight: 600;
    color: var(--text);
    padding: 4px 0;
}

.detail-title-input:focus { outline: none; }

.detail-format-select {
    background: var(--bg3);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 12px;
    cursor: pointer;
}

.detail-close {
    background: var(--bg3);
    border: none;
    color: var(--text);
    width: 30px;
    height: 30px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
}

.detail-actions {
    display: flex;
    gap: 8px;
}

.detail-actions button {
    padding: 6px 14px;
    background: var(--bg3);
    border: none;
    color: var(--text);
    border-radius: 5px;
    cursor: pointer;
    font-size: 12px;
}

.detail-actions button.save-btn { background: var(--accent); color: #fff; }
.detail-actions button.save-btn:hover { background: #5b4cdb; }
.detail-actions button:hover { background: var(--accent); }
.detail-actions button.delete:hover { background: var(--red); }
.detail-actions .image-btn { background: var(--bg3); }
.detail-actions .image-btn:hover { background: var(--accent); }

/* View mode vs Edit mode */
.detail-panel.view-mode .detail-title-input {
    display: none;
}

.detail-panel.view-mode .detail-title-display {
    display: block;
}

.detail-panel:not(.view-mode) .detail-title-display {
    display: none;
}

.detail-title-display {
    flex: 1;
    font-size: 18px;
    font-weight: 600;
    color: var(--text);
    padding: 4px 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.detail-panel.view-mode .edit-mode-only {
    display: none;
}

.detail-panel:not(.view-mode) .view-mode-only {
    display: none;
}

.edit-btn {
    padding: 6px 14px;
    background: var(--accent);
    border: none;
    color: white;
    border-radius: 5px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
}

.edit-btn:hover {
    background: #5b4cdb;
}

.detail-panel.view-mode .live-preview {
    cursor: default;
}

.detail-panel.view-mode .live-preview:empty::before {
    content: 'No content';
}

.detail-live-editor {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    overflow: hidden;
    position: relative;
}

/* Split view for edit mode */
.detail-panel:not(.view-mode) .detail-live-editor {
    flex-direction: row;
}

.detail-editor-pane {
    display: none;
    flex: 1;
    flex-direction: column;
    border-right: 1px solid var(--border);
    min-width: 0;
}

.detail-panel:not(.view-mode) .detail-editor-pane {
    display: flex;
}

.detail-editor-pane textarea {
    flex: 1;
    padding: 20px;
    background: var(--bg);
    border: none;
    color: var(--text);
    font-size: 14px;
    font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
    line-height: 1.7;
    resize: none;
    outline: none;
}

.detail-editor-pane textarea::placeholder {
    color: var(--text2);
}

.detail-preview-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
    min-height: 0;
    overflow: hidden;
}

/* In view mode, preview takes full width */
.detail-panel.view-mode .detail-preview-pane {
    flex: 1;
}

/* In edit mode, both panes share space */
.detail-panel:not(.view-mode) .detail-preview-pane {
    flex: 1;
}

.live-preview {
    flex: 1;
    padding: 24px;
    font-size: 15px;
    line-height: 1.8;
    overflow-y: auto;
    overflow-x: hidden;
    background: var(--bg);
    cursor: default;
    min-height: 0;
}

.live-preview:empty::before {
    content: 'Click here to start writing...';
    color: var(--text2);
    font-style: italic;
}

.live-preview img {
    max-width: 100%;
    border-radius: 8px;
    margin: 10px 0;
}

.inline-image {
    display: block;
    max-width: 100%;
    border-radius: 8px;
    margin: 10px 0;
    cursor: grab;
    border: 2px solid transparent;
    transition: border-color 0.2s;
}

.inline-image:hover {
    border-color: var(--accent);
}

.inline-image.dragging {
    opacity: 0.5;
    cursor: grabbing;
}

.attached-images {
    margin-top: 16px;
}

.attached-image {
    position: relative;
    display: inline-block;
    margin: 8px 0;
    cursor: pointer;
}

.attached-image img {
    max-width: 100%;
    border-radius: 8px;
    border: 2px solid transparent;
    transition: border-color 0.15s;
}

.attached-image:hover img {
    border-color: var(--accent);
}

.attached-image.selected img {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.3);
}

.attached-image .image-controls {
    display: none;
    position: absolute;
    top: 8px;
    right: 8px;
    gap: 4px;
}

.attached-image.selected .image-controls {
    display: flex;
}

.attached-image .image-controls button {
    width: 28px;
    height: 28px;
    border: none;
    border-radius: 6px;
    background: var(--bg2);
    color: var(--text);
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.attached-image .image-controls button:hover {
    background: var(--accent);
}

.attached-image .resize-handle {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 24px;
    height: 24px;
    background: var(--accent);
    border-radius: 6px 0 6px 0;
    cursor: nwse-resize;
    display: none;
    opacity: 0.9;
}

.attached-image .resize-handle::after {
    content: '‚§°';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 14px;
}

.attached-image.selected .resize-handle {
    display: block;
}

.image-drop-zone {
    height: 4px;
    background: var(--accent);
    margin: 4px 0;
    border-radius: 2px;
    opacity: 0;
    transition: opacity 0.2s;
}

.image-drop-zone.active {
    opacity: 1;
}

.live-preview code {
    background: rgba(108, 92, 231, 0.15);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'SF Mono', Monaco, monospace;
    font-size: 0.9em;
}

.live-preview h2, .live-preview h3, .live-preview h4 {
    margin: 20px 0 10px 0;
    color: var(--text);
}

.live-preview h2 { font-size: 24px; font-weight: 700; }
.live-preview h3 { font-size: 20px; font-weight: 600; }
.live-preview h4 { font-size: 17px; font-weight: 600; }

.live-preview li { margin-left: 24px; margin-bottom: 6px; }

.live-preview blockquote {
    border-left: 4px solid var(--accent);
    padding-left: 16px;
    margin: 16px 0;
    color: var(--text2);
    font-style: italic;
}

.live-preview strong { color: var(--text); }

.live-preview .katex-display {
    margin: 20px 0;
    overflow-x: auto;
}

.live-textarea {
    flex: 1;
    padding: 24px;
    background: var(--bg);
    border: none;
    color: var(--text);
    font-size: 15px;
    font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
    line-height: 1.8;
    resize: none;
    overflow-y: auto;
}

.live-textarea:focus { outline: none; }
.live-textarea::placeholder { color: var(--text2); }

.detail-meta {
    padding: 12px 20px;
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 20px;
    font-size: 12px;
    color: var(--text2);
}

.detail-flashcard-label {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
}

.detail-fsrs-stats {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 15px;
    margin: 8px 0;
    padding: 10px;
    background: var(--bg);
    border-radius: 8px;
    font-size: 12px;
}

.fsrs-stat {
    display: flex;
    gap: 5px;
}

.fsrs-label {
    color: var(--text2);
}

.detail-links {
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;
}

.edit-hint {
    margin-left: auto;
    color: var(--text2);
    font-style: italic;
}

/* Obsidian-style live preview */
.live-preview-content {
    padding: 15px 20px;
    line-height: 1.8;
    font-size: 15px;
    color: var(--text);
}

.live-preview-content:empty::before {
    content: "Click to start writing...";
    color: var(--text2);
    font-style: italic;
    cursor: text;
}

/* Editable formulas in detail panel */
.live-preview-content .detail-formula {
    cursor: pointer;
    border-radius: 4px;
    padding: 2px 4px;
    margin: 0 2px;
    transition: background 0.15s;
}

.live-preview-content .detail-formula:hover {
    background: rgba(108, 92, 231, 0.15);
}

.live-preview-content .detail-formula.editing {
    background: rgba(108, 92, 231, 0.2);
    outline: 2px solid var(--accent);
}

/* Formula inline editor in detail panel */
.detail-formula-editor {
    display: block;
    margin: 10px 0;
}

.detail-formula-editor textarea {
    width: 100%;
    min-height: 80px;
    padding: 12px 14px;
    background: var(--bg2);
    border: 2px solid var(--accent);
    border-radius: 8px;
    color: var(--text);
    font-size: 15px;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
    line-height: 1.6;
    resize: vertical;
}

.detail-formula-editor textarea:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
}

/* Editable text in detail panel */
.live-preview-content .detail-text {
    cursor: text;
    border-radius: 3px;
    transition: background 0.15s;
}

.live-preview-content .detail-text:hover {
    background: rgba(255, 255, 255, 0.08);
}

.live-preview-content .detail-text.editing {
    display: block;
    background: transparent;
}

/* Text inline editor */
.detail-text-editor {
    display: block;
    width: 100%;
    margin: 4px 0;
}

.detail-text-editor textarea {
    width: 100%;
    min-height: 60px;
    padding: 12px 14px;
    background: var(--bg);
    border: 2px solid var(--accent);
    border-radius: 6px;
    color: var(--text);
    font-size: 15px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    line-height: 1.7;
    resize: none;
    overflow: hidden;
}

.detail-text-editor textarea:focus {
    outline: none;
}

/* Full content editor */
.full-content-editor {
    width: 100%;
    min-height: 200px;
    padding: 15px;
    background: var(--bg);
    border: none;
    border-radius: 0;
    color: var(--text);
    font-size: 15px;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
    line-height: 1.7;
    resize: none;
}

.full-content-editor:focus {
    outline: none;
}

.detail-content blockquote {
    border-left: 3px solid var(--accent);
    padding-left: 15px;
    margin: 10px 0;
    color: var(--text2);
}

.detail-meta {
    padding: 15px 20px;
    border-top: 1px solid var(--border);
    font-size: 12px;
    color: var(--text2);
}

.detail-meta .links-list { margin-top: 10px; }

.detail-meta .link-item {
    display: inline-block;
    background: var(--bg3);
    padding: 4px 10px;
    border-radius: 15px;
    margin: 3px 3px 3px 0;
    cursor: pointer;
}

.detail-meta .link-item:hover { background: var(--accent); }

.flashcards-view, .quiz-view {
    display: none;
    flex: 1;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px;
    text-align: center;
}

.flashcards-view.active, .quiz-view.active { display: flex; }

#fcStartScreen, #fcReviewScreen, #fcCompleteScreen {
    display: none;
    flex-direction: column;
    align-items: center;
    width: 100%;
}

#fcStartScreen { display: flex; }

.view-icon { font-size: 64px; margin-bottom: 20px; }
.view-title { font-size: 28px; font-weight: 600; margin-bottom: 10px; }
.view-desc { color: var(--text2); max-width: 400px; line-height: 1.6; margin-bottom: 30px; }

.stats-row {
    display: flex;
    gap: 30px;
    margin-bottom: 30px;
}

.stat-box {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px 30px;
    text-align: center;
}

.stat-number {
    font-size: 36px;
    font-weight: 700;
    color: var(--accent);
}

.stat-number.orange { color: var(--orange); }
.stat-number.green { color: var(--green); }
.stat-label { font-size: 12px; color: var(--text2); margin-top: 5px; }

.big-btn {
    padding: 15px 40px;
    font-size: 16px;
    background: var(--accent);
    border: none;
    color: var(--text);
    border-radius: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 10px;
}

.big-btn:hover { background: var(--accent2); }
.big-btn.orange { background: var(--orange); color: #000; }
.big-btn.green { background: var(--green); color: var(--text); }
.big-btn:disabled { opacity: 0.5; cursor: not-allowed; }

/* ==================== FLASHCARD REVIEW STYLES ==================== */

.fc-stats-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
    margin-bottom: 30px;
    max-width: 500px;
}

.stat-number.blue { color: var(--blue); }

.fc-chart-container {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 25px;
    max-width: 450px;
    width: 100%;
}

.fc-chart-container h4 {
    margin-bottom: 15px;
    font-size: 14px;
    color: var(--text2);
}

.chart-placeholder {
    color: var(--text2);
    font-size: 13px;
    text-align: center;
    padding: 30px;
}

.fc-distribution {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 30px;
    max-width: 450px;
    width: 100%;
}

.fc-distribution h4 {
    margin-bottom: 15px;
    font-size: 14px;
    color: var(--text2);
}

.distribution-bar {
    height: 24px;
    background: var(--bg);
    border-radius: 12px;
    overflow: hidden;
    display: flex;
    margin-bottom: 12px;
}

.dist-segment {
    height: 100%;
    transition: width 0.3s ease;
}

.dist-segment.new { background: var(--blue); }
.dist-segment.learning { background: var(--orange); }
.dist-segment.review { background: var(--green); }
.dist-segment.relearning { background: var(--red); }

.distribution-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    justify-content: center;
    font-size: 12px;
    color: var(--text2);
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
}

.legend-item .dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
}

.dot.new { background: var(--blue); }
.dot.learning { background: var(--orange); }
.dot.review { background: var(--green); }
.dot.relearning { background: var(--red); }

/* Review Session */
.fc-review-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    max-width: 600px;
    margin-bottom: 30px;
}

.fc-progress {
    display: flex;
    align-items: center;
    gap: 15px;
}

.fc-progress-bar {
    width: 200px;
    height: 8px;
    background: var(--bg);
    border-radius: 4px;
    overflow: hidden;
}

.fc-progress-fill {
    height: 100%;
    background: var(--green);
    transition: width 0.3s ease;
}

.fc-end-btn {
    padding: 8px 16px;
    background: var(--bg2);
    border: 1px solid var(--border);
    color: var(--text2);
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
}

.fc-end-btn:hover {
    background: var(--red);
    color: var(--text);
    border-color: var(--red);
}

.fc-card-container {
    width: 100%;
    max-width: 600px;
    margin-bottom: 30px;
}

.fc-card {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 30px;
    min-height: 300px;
    display: flex;
    flex-direction: column;
}

.fc-card-topic {
    font-size: 12px;
    color: var(--text2);
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid var(--border);
}

.fc-card-title {
    font-size: 20px;
    margin-bottom: 20px;
    color: var(--text);
}

.fc-card-content {
    color: var(--text);
    line-height: 1.6;
    max-height: 150px;
    overflow: hidden;
}

.fc-card-back {
    border-top: 1px dashed var(--border);
    padding-top: 20px;
    margin-top: 20px;
}

.fc-card-answer {
    color: var(--text);
    line-height: 1.6;
    max-height: 200px;
    overflow-y: auto;
}

.fc-card-info {
    display: flex;
    gap: 15px;
    margin-top: 15px;
    justify-content: center;
}

.fc-info-item {
    font-size: 11px;
    color: var(--text2);
    background: var(--bg3);
    padding: 4px 10px;
    border-radius: 12px;
}

.fc-show-answer {
    margin-bottom: 20px;
}

.fc-rating-section {
    text-align: center;
}

.fc-rating-label {
    color: var(--text2);
    margin-bottom: 15px;
    font-size: 14px;
}

.fc-rating-buttons {
    display: flex;
    gap: 12px;
    justify-content: center;
}

.fc-rating-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 15px 25px;
    border: 2px solid var(--border);
    border-radius: 12px;
    background: var(--bg2);
    cursor: pointer;
    transition: all 0.15s;
    min-width: 80px;
}

.fc-rating-btn:hover {
    transform: translateY(-2px);
}

.fc-rating-btn .rating-label {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 4px;
}

.fc-rating-btn .rating-interval {
    font-size: 11px;
    color: var(--text2);
}

.fc-rating-btn.again {
    border-color: var(--red);
    color: var(--red);
}
.fc-rating-btn.again:hover {
    background: var(--red);
    color: var(--text);
}

.fc-rating-btn.hard {
    border-color: var(--orange);
    color: var(--orange);
}
.fc-rating-btn.hard:hover {
    background: var(--orange);
    color: #000;
}

.fc-rating-btn.good {
    border-color: var(--green);
    color: var(--green);
}
.fc-rating-btn.good:hover {
    background: var(--green);
    color: var(--text);
}

.fc-rating-btn.easy {
    border-color: var(--blue);
    color: var(--blue);
}
.fc-rating-btn.easy:hover {
    background: var(--blue);
    color: var(--text);
}

/* Session Complete */
.fc-session-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin: 30px 0;
    max-width: 400px;
}

.fc-session-breakdown {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 30px;
    max-width: 350px;
    width: 100%;
}

.fc-session-breakdown h4 {
    margin-bottom: 15px;
    font-size: 14px;
    color: var(--text2);
}

.rating-breakdown {
    display: flex;
    justify-content: space-around;
}

.rating-item {
    text-align: center;
}

.rating-count {
    font-size: 24px;
    font-weight: 600;
}

.rating-name {
    font-size: 11px;
    color: var(--text2);
}

.rating-item.again .rating-count { color: var(--red); }
.rating-item.hard .rating-count { color: var(--orange); }
.rating-item.good .rating-count { color: var(--green); }
.rating-item.easy .rating-count { color: var(--blue); }

/* Flashcard Mode Buttons */
.fc-mode-buttons {
    display: flex;
    gap: 15px;
    margin-top: 10px;
}

.fc-mode-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px 30px;
    background: var(--bg2);
    border: 2px solid var(--border);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.15s;
    min-width: 150px;
}

.fc-mode-btn:hover:not(:disabled) {
    border-color: var(--accent);
    transform: translateY(-2px);
}

.fc-mode-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.fc-mode-btn .mode-icon {
    font-size: 28px;
    margin-bottom: 8px;
}

.fc-mode-btn .mode-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--text);
    margin-bottom: 4px;
}

.fc-mode-btn .mode-desc {
    font-size: 12px;
    color: var(--text2);
}

.quiz-topics {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    margin-bottom: 30px;
    max-width: 500px;
}

.quiz-topic-btn {
    padding: 10px 20px;
    background: var(--bg2);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 20px;
    cursor: pointer;
    font-size: 13px;
}

.quiz-topic-btn:hover { border-color: var(--accent); }
.quiz-topic-btn.selected { background: var(--accent); border-color: var(--accent); }

.export-box {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    margin-top: 20px;
    max-width: 500px;
    width: 100%;
}

.export-box h4 { margin-bottom: 10px; font-size: 14px; }

.export-box textarea {
    width: 100%;
    height: 150px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    padding: 12px;
    font-family: monospace;
    font-size: 11px;
    resize: none;
}

.export-box .actions {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.export-box button {
    padding: 8px 16px;
    background: var(--bg3);
    border: none;
    color: var(--text);
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
}

.export-box button:hover { background: var(--accent); }

.sync-status {
    padding: 10px 15px;
    background: var(--bg3);
    border-bottom: 1px solid var(--border);
    font-size: 11px;
    color: var(--text2);
    display: none;
    align-items: center;
    gap: 8px;
}

.sync-status.active { display: flex; }
.sync-status .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--green);
}

.modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    justify-content: center;
    align-items: flex-start;
    padding: 50px;
    z-index: 1000;
    overflow-y: auto;
}

.modal-overlay.visible { display: flex; }

.modal {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-radius: 12px;
    width: 100%;
    max-width: 600px;
}

.modal-header {
    padding: 20px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
}

.modal-header h2 { flex: 1; font-size: 18px; }

.modal-close {
    background: var(--bg3);
    border: none;
    color: var(--text);
    width: 32px;
    height: 32px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 18px;
}

.modal-body { padding: 20px; }
.form-group { margin-bottom: 20px; }

.form-group label {
    display: block;
    font-size: 13px;
    color: var(--text2);
    margin-bottom: 6px;
}

.form-group input {
    width: 100%;
    padding: 12px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-size: 14px;
}

.form-group input:focus {
    outline: none;
    border-color: var(--accent);
}

.editor-wrapper {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    transition: border-color 0.2s;
}

.editor-wrapper.drag-over {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(108, 92, 231, 0.2);
}

.editor-toolbar {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    border-bottom: 1px solid var(--border);
    gap: 2px;
    flex-wrap: wrap;
}

.toolbar-group {
    display: flex;
    align-items: center;
    gap: 2px;
}

.toolbar-sep {
    width: 1px;
    height: 20px;
    background: var(--border);
    margin: 0 8px;
}

.editor-toolbar .toolbar-btn {
    width: 32px;
    height: 32px;
    background: transparent;
    border: none;
    color: var(--text2);
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.1s;
}

.editor-toolbar .toolbar-btn:hover { background: var(--bg3); color: var(--text); }
.editor-toolbar .toolbar-btn.hl-yellow:hover { background: #ffeaa7; color: #000; }
.editor-toolbar .toolbar-btn.hl-green:hover { background: #55efc4; color: #000; }
.editor-toolbar .toolbar-btn.hl-pink:hover { background: #fd79a8; color: #000; }
.editor-toolbar .toolbar-btn.image-btn {
    background: var(--accent);
    color: var(--text);
    font-size: 12px;
    font-weight: 600;
    padding: 0 12px;
    width: auto;
}
.editor-toolbar .toolbar-btn.image-btn:hover {
    background: var(--accent2);
    color: var(--text);
}

.editor-main {
    display: flex;
    flex: 1;
    min-height: 0;
    overflow: hidden;
}

.editor-input {
    flex: 1;
    padding: 16px;
    background: transparent;
    border: none;
    color: var(--text);
    font-size: 14px;
    font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
    line-height: 1.7;
    resize: none;
    height: 100%;
    overflow-y: auto;
}

.editor-input:focus { outline: none; }
.editor-input::placeholder { color: var(--text2); }

.editor-preview {
    flex: 1;
    padding: 16px;
    border-left: 1px solid var(--border);
    font-size: 14px;
    line-height: 1.7;
    overflow-y: auto;
    background: var(--bg2);
}

.editor-preview:empty::before {
    content: 'Preview...';
    color: var(--text2);
}

.editor-preview h2, .editor-preview h3, .editor-preview h4 {
    margin: 16px 0 8px 0;
    color: var(--text);
}

.editor-preview h2 { font-size: 20px; }
.editor-preview h3 { font-size: 17px; }
.editor-preview h4 { font-size: 15px; }

.editor-preview li {
    margin-left: 20px;
    margin-bottom: 4px;
}

.editor-preview code {
    background: rgba(108, 92, 231, 0.2);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'SF Mono', Monaco, monospace;
    font-size: 13px;
}

.editor-preview blockquote {
    border-left: 3px solid var(--accent);
    padding-left: 12px;
    margin: 12px 0;
    color: var(--text2);
    font-style: italic;
}

.editor-preview .katex-display {
    margin: 16px 0;
    overflow-x: auto;
}

.editor-preview .katex { font-size: 1.1em; }

.preview-images {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px dashed var(--border);
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.preview-image img {
    max-width: 150px;
    max-height: 100px;
    border-radius: 6px;
    object-fit: cover;
    border: 1px solid var(--border);
}

.editor-footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    border-top: 1px solid var(--border);
    font-size: 11px;
    color: var(--text2);
}

.editor-footer-left {
    display: flex;
    align-items: center;
    gap: 15px;
}

.editor-footer label {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
}

.editor-footer input[type="checkbox"] {
    width: 16px;
    height: 16px;
    accent-color: var(--orange);
}

.char-count { color: var(--text2); }

.image-attach {
    display: flex;
    align-items: center;
    gap: 8px;
}

.image-attach-btn {
    padding: 6px 12px;
    background: var(--bg3);
    border: none;
    color: var(--text2);
    border-radius: 4px;
    cursor: pointer;
    font-size: 11px;
}

.image-attach-btn:hover { background: var(--accent); color: var(--text); }

.image-thumbs-mini {
    display: flex;
    gap: 4px;
}

.image-thumb-mini {
    width: 28px;
    height: 28px;
    border-radius: 4px;
    overflow: hidden;
    position: relative;
}

.image-thumb-mini img { width: 100%; height: 100%; object-fit: cover; }

.image-thumb-mini:hover::after {
    content: '\00d7';
    position: absolute;
    inset: 0;
    background: rgba(231,76,60,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text);
    font-size: 14px;
    cursor: pointer;
}

.modal-footer {
    padding: 15px 20px;
    border-top: 1px solid var(--border);
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.btn {
    padding: 10px 20px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-size: 13px;
}

.btn-ghost { background: var(--bg3); color: var(--text); }
.btn-primary { background: var(--accent); color: var(--text); }

.toast {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%) translateY(20px);
    background: var(--bg2);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 12px 24px;
    border-radius: 10px;
    font-size: 13px;
    font-weight: 500;
    opacity: 0;
    transition: all 0.3s ease;
    z-index: 9999;
    box-shadow: 0 10px 40px rgba(0,0,0,0.2);
}

.toast.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}

    </style>
</head>
<body>
    <div class="app">
        <!-- Sidebar Toggle (outside sidebar so it's always visible) -->
        <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()">&#9664;</button>
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <span><span style="color:var(--accent)">M</span>indNotes</span>
                <div class="header-actions">
                    <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Toggle Theme">üåô</button>
                    <button class="sync-btn" onclick="downloadLocalBackup()" title="Save Local Backup">üíæ</button>
                    <button class="sync-btn" onclick="importFromJson()" title="Import JSON">üì•</button>
                    <button class="sync-btn" id="syncBtn" onclick="openSyncModal()" title="Cloud Sync">‚òÅÔ∏è</button>
                </div>
            </div>
            <div class="sync-status" id="syncStatus">
                <span class="dot"></span>
                <span id="syncStatusText">Connected</span>
            </div>
            <div class="search-bar">
                <input type="text" class="search-input" id="searchInput" placeholder="Search all notes..." oninput="performSearch(this.value)">
            </div>
            <div class="search-results" id="searchResults"></div>
            <div class="nav-tabs">
                <button class="nav-tab active" id="tabNotes" onclick="switchView('notes')">
                    <span class="icon">üìù</span>
                    Notes
                </button>
                <button class="nav-tab" id="tabFlashcards" onclick="switchView('flashcards')">
                    <span class="icon">üé¥</span>
                    <span id="fcBadge" class="badge" style="display:none">0</span>
                    Cards
                </button>
                <button class="nav-tab" id="tabQuiz" onclick="switchView('quiz')">
                    <span class="icon">üß†</span>
                    Quiz
                </button>
            </div>
            <div class="topics-section" id="topicsSection"></div>
            <button class="add-btn" onclick="openTopicModal()">+ New Topic</button>
            <div class="trash-section">
                <button class="trash-btn" onclick="openTrashModal()">
                    <span>üóëÔ∏è</span>
                    <span>Trash</span>
                    <span class="trash-count" id="trashCount">0</span>
                </button>
            </div>
        </div>

        <!-- Main area -->
        <div class="main">
            <!-- Notes Canvas View -->
            <div class="canvas-wrapper" id="canvasWrapper">
                <div class="canvas-bg" id="canvasBg"></div>
                <div class="canvas" id="canvas">
                    <svg id="linksSvg" width="10000" height="10000" style="position:absolute;top:0;left:0;overflow:visible;pointer-events:none;"></svg>
                </div>
                <div class="canvas-toolbar">
                    <button class="toolbar-btn" onclick="fitView()">Fit View</button>
                </div>
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="zoomOut()">-</button>
                    <div class="zoom-level" id="zoomLevel">100%</div>
                    <button class="zoom-btn" onclick="zoomIn()">+</button>
                </div>
                <div class="canvas-hint">Dbl-click = new note | Shift+drag = select area | Cmd+A = select all | Cmd+C/V = copy/paste | Cmd+click = link</div>
            </div>

            <!-- Selection toolbar for bulk operations -->
            <div class="selection-toolbar" id="selectionToolbar">
                <span class="selection-count" id="selectionCount">0 selected</span>
                <button onclick="copySelectedNotes()" title="Copy (Cmd+C)">Copy</button>
                <button onclick="showMoveMenu()" id="moveMenuBtn" title="Move to another subtopic">Move to...</button>
                <button class="delete-btn" onclick="deleteSelectedNodes()" title="Delete (Del x2)">Delete</button>
                <button onclick="clearSelection()" title="Clear selection">Clear</button>
                <div class="move-menu" id="moveMenu"></div>
            </div>

            <!-- Detail panel - Obsidian-style live editor -->
            <div class="detail-panel view-mode" id="detailPanel">
                <div class="detail-header">
                    <span class="detail-title-display" id="detailTitleDisplay">Untitled</span>
                    <input type="text" id="detailTitle" placeholder="Note Title" class="detail-title-input edit-mode-only">
                    <select id="detailFormatSelector" onchange="renderDetailView()" class="detail-format-select edit-mode-only">
                        <option value="latex">LaTeX</option>
                        <option value="obsidian">Obsidian</option>
                        <option value="chatgpt">ChatGPT</option>
                    </select>
                    <div class="detail-actions edit-mode-only">
                        <input type="file" id="detailImageInput" accept="image/*" multiple style="display:none">
                        <button class="image-btn" onmousedown="event.preventDefault(); triggerDetailImageUpload()">+ Image</button>
                    </div>
                    <button class="edit-btn view-mode-only" onclick="enterDetailEditMode()">Edit</button>
                    <button class="edit-btn edit-mode-only" onclick="exitDetailEditMode()" style="background: var(--green);">Done</button>
                    <button class="detail-close" onclick="closeDetail()">&times;</button>
                </div>
                <div class="detail-live-editor" id="detailLiveEditor">
                    <!-- Editor pane (left side in edit mode) -->
                    <div class="detail-editor-pane">
                        <textarea id="detailContentEditor" placeholder="Write your note here..."></textarea>
                    </div>
                    <!-- Preview pane (right side in edit mode, full width in view mode) -->
                    <div class="detail-preview-pane">
                        <div class="live-preview" id="detailPreview"></div>
                    </div>
                </div>
                <div class="detail-meta">
                    <span class="flashcard-badge view-mode-only" id="flashcardBadge" style="display:none; background: var(--orange); color: #000; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">Flashcard</span>
                    <label class="detail-flashcard-label edit-mode-only">
                        <input type="checkbox" id="detailFlashcard" onchange="toggleFlashcardDetail()"> Flashcard
                    </label>
                    <div class="detail-fsrs-stats" id="detailFsrsStats" style="display:none;">
                        <div class="fsrs-stat"><span class="fsrs-label">State:</span> <span id="fsrsState">New</span></div>
                        <div class="fsrs-stat"><span class="fsrs-label">Due:</span> <span id="fsrsDue">Now</span></div>
                        <div class="fsrs-stat"><span class="fsrs-label">Stability:</span> <span id="fsrsStability">1.0</span></div>
                        <div class="fsrs-stat"><span class="fsrs-label">Reps:</span> <span id="fsrsReps">0</span></div>
                    </div>
                    <div class="detail-links">
                        <span>Links:</span>
                        <div class="links-list" id="linksListDetail"></div>
                    </div>
                </div>
            </div>

            <!-- Flashcards View -->
            <div class="flashcards-view" id="flashcardsView">
                <!-- Start Screen -->
                <div id="fcStartScreen">
                    <div class="view-icon">üé¥</div>
                    <h2 class="view-title">Flashcard Review</h2>
                    <p class="view-desc">Anki-style spaced repetition with FSRS algorithm for optimal learning.</p>

                    <!-- Stats Overview -->
                    <div class="fc-stats-grid">
                        <div class="stat-box">
                            <div class="stat-number orange" id="fcDueCards">0</div>
                            <div class="stat-label">Due Today</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number green" id="fcNewCards">0</div>
                            <div class="stat-label">New</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number blue" id="fcLearningCards">0</div>
                            <div class="stat-label">Learning</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="fcTotalCards">0</div>
                            <div class="stat-label">Total</div>
                        </div>
                    </div>

                    <!-- Retention Chart -->
                    <div class="fc-chart-container">
                        <h4>Retention Over Time</h4>
                        <canvas id="retentionChart" width="400" height="150"></canvas>
                        <div id="chartPlaceholder" class="chart-placeholder">
                            Start reviewing to see your retention stats
                        </div>
                    </div>

                    <!-- Card State Distribution -->
                    <div class="fc-distribution">
                        <h4>Card States</h4>
                        <div class="distribution-bar" id="fcDistributionBar">
                            <div class="dist-segment new" id="distNew" style="width:0%"></div>
                            <div class="dist-segment learning" id="distLearning" style="width:0%"></div>
                            <div class="dist-segment review" id="distReview" style="width:0%"></div>
                            <div class="dist-segment relearning" id="distRelearning" style="width:0%"></div>
                        </div>
                        <div class="distribution-legend">
                            <span class="legend-item"><span class="dot new"></span> New</span>
                            <span class="legend-item"><span class="dot learning"></span> Learning</span>
                            <span class="legend-item"><span class="dot review"></span> Review</span>
                            <span class="legend-item"><span class="dot relearning"></span> Relearning</span>
                        </div>
                    </div>

                    <div class="fc-mode-buttons">
                        <button class="fc-mode-btn" onclick="startFlashcards('optimal')" id="startFcBtn" disabled>
                            <span class="mode-icon">üéØ</span>
                            <span class="mode-title">Optimal Spacing</span>
                            <span class="mode-desc" id="fcOptimalDesc">0 cards due</span>
                        </button>
                        <button class="fc-mode-btn" onclick="startFlashcards('all')" id="startAllBtn" disabled>
                            <span class="mode-icon">üìö</span>
                            <span class="mode-title">All Cards</span>
                            <span class="mode-desc" id="fcAllDesc">0 cards total</span>
                        </button>
                    </div>
                </div>

                <!-- Review Session Screen -->
                <div id="fcReviewScreen" style="display:none;">
                    <div class="fc-review-header">
                        <div class="fc-progress">
                            <span id="fcProgress">0/0</span>
                            <div class="fc-progress-bar">
                                <div class="fc-progress-fill" id="fcProgressFill" style="width:0%"></div>
                            </div>
                        </div>
                        <button class="fc-end-btn" onclick="endFlashcardSession()">End Session</button>
                    </div>

                    <div class="fc-card-container">
                        <div class="fc-card" id="fcCard">
                            <div class="fc-card-topic" id="fcCardTopic">Topic > Subtopic</div>
                            <div class="fc-card-front" id="fcCardFront">
                                <h3 class="fc-card-title" id="fcCardTitle">Card Title</h3>
                                <div class="fc-card-content" id="fcCardContent">
                                    Content preview...
                                </div>
                            </div>
                            <div class="fc-card-back" id="fcCardBack" style="display:none;">
                                <div class="fc-card-answer" id="fcCardAnswer">
                                    Full content here...
                                </div>
                            </div>
                        </div>

                        <div class="fc-card-info" id="fcCardInfo">
                            <span class="fc-info-item" id="fcCardState">New</span>
                            <span class="fc-info-item" id="fcCardReps">0 reps</span>
                            <span class="fc-info-item" id="fcCardStability">Stability: 1.0</span>
                        </div>
                    </div>

                    <!-- Show Answer Button -->
                    <div class="fc-show-answer" id="fcShowAnswerSection">
                        <button class="big-btn" onclick="showFlashcardAnswer()">
                            Show Answer
                        </button>
                    </div>

                    <!-- Rating Buttons -->
                    <div class="fc-rating-section" id="fcRatingSection" style="display:none;">
                        <p class="fc-rating-label">How well did you remember?</p>
                        <div class="fc-rating-buttons">
                            <button class="fc-rating-btn again" onclick="rateFlashcard(1)">
                                <span class="rating-label">Again</span>
                                <span class="rating-interval" id="fcInterval1">&lt;1d</span>
                            </button>
                            <button class="fc-rating-btn hard" onclick="rateFlashcard(2)">
                                <span class="rating-label">Hard</span>
                                <span class="rating-interval" id="fcInterval2">1d</span>
                            </button>
                            <button class="fc-rating-btn good" onclick="rateFlashcard(3)">
                                <span class="rating-label">Good</span>
                                <span class="rating-interval" id="fcInterval3">3d</span>
                            </button>
                            <button class="fc-rating-btn easy" onclick="rateFlashcard(4)">
                                <span class="rating-label">Easy</span>
                                <span class="rating-interval" id="fcInterval4">7d</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Session Complete Screen -->
                <div id="fcCompleteScreen" style="display:none;">
                    <div class="view-icon">üéâ</div>
                    <h2 class="view-title">Session Complete!</h2>
                    <div class="fc-session-stats">
                        <div class="stat-box">
                            <div class="stat-number green" id="fcSessionReviewed">0</div>
                            <div class="stat-label">Cards Reviewed</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" id="fcSessionCorrect">0%</div>
                            <div class="stat-label">Retention Rate</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number blue" id="fcSessionTime">0m</div>
                            <div class="stat-label">Study Time</div>
                        </div>
                    </div>
                    <div class="fc-session-breakdown">
                        <h4>Rating Breakdown</h4>
                        <div class="rating-breakdown" id="fcRatingBreakdown"></div>
                    </div>
                    <button class="big-btn orange" onclick="showFlashcardStart()">
                        Back to Overview
                    </button>
                </div>
            </div>

            <!-- Quiz View -->
            <div class="quiz-view" id="quizView">
                <div class="view-icon">üß†</div>
                <h2 class="view-title">AI Quiz Generator</h2>
                <p class="view-desc">Select topics to generate a quiz based on your notes.</p>
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-number green" id="quizTotalNotes">0</div>
                        <div class="stat-label">Total Notes</div>
                    </div>
                </div>
                <div class="quiz-topics" id="quizTopics"></div>
                <button class="big-btn green" onclick="exportForQuiz()" id="exportQuizBtn">
                    Export Notes for Quiz
                </button>
                <div class="export-box" id="exportBox" style="display:none">
                    <h4>Your Notes (copy this to Claude)</h4>
                    <textarea id="exportText" readonly></textarea>
                    <div class="actions">
                        <button onclick="copyExport()">Copy to Clipboard</button>
                        <button onclick="document.getElementById('exportBox').style.display='none'">Close</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Node Modal -->
    <div class="modal-overlay" id="nodeModal">
        <div class="modal" style="width:90vw;max-width:none;height:90vh;display:flex;flex-direction:column;">
            <div class="modal-header" style="padding:12px 20px;">
                <input type="text" id="nodeTitle" placeholder="Untitled" style="background:transparent;border:none;font-size:18px;font-weight:600;color:var(--text);flex:1;padding:0;" onfocus="this.select()">
                <select id="formatSelector" onchange="updatePreview()" style="background:var(--bg3);border:1px solid var(--border);color:var(--text);padding:6px 12px;border-radius:6px;font-size:12px;cursor:pointer;">
                    <option value="latex">LaTeX (KaTeX)</option>
                    <option value="obsidian">Obsidian</option>
                </select>
                <button class="modal-close" onclick="closeNodeModal()">&times;</button>
            </div>
            <div class="editor-wrapper">
                <div class="editor-toolbar">
                    <div class="toolbar-group">
                        <button type="button" class="toolbar-btn" onclick="insertFormat('**','**')" title="Bold"><b>B</b></button>
                        <button type="button" class="toolbar-btn" onclick="insertFormat('*','*')" title="Italic"><i>I</i></button>
                        <button type="button" class="toolbar-btn" onclick="insertFormat('\`','\`')" title="Code">&lt;/&gt;</button>
                    </div>
                    <div class="toolbar-sep"></div>
                    <div class="toolbar-group">
                        <button type="button" class="toolbar-btn" onclick="insertFormat('$','$')" title="Inline LaTeX">ùë•</button>
                        <button type="button" class="toolbar-btn" onclick="insertFormat('\n$$\n','\n$$\n')" title="Block LaTeX">‚àë</button>
                    </div>
                    <div class="toolbar-sep"></div>
                    <div class="toolbar-group">
                        <button type="button" class="toolbar-btn hl-yellow" onclick="insertHighlight('yellow')" title="Yellow" style="font-size:10px;">‚óè</button>
                        <button type="button" class="toolbar-btn hl-green" onclick="insertHighlight('green')" title="Green" style="font-size:10px;">‚óè</button>
                        <button type="button" class="toolbar-btn hl-pink" onclick="insertHighlight('pink')" title="Pink" style="font-size:10px;">‚óè</button>
                    </div>
                    <div class="toolbar-sep"></div>
                    <div class="toolbar-group">
                        <button type="button" class="toolbar-btn" onclick="insertFormat('\n- ','')" title="List">‚Ä¢</button>
                        <button type="button" class="toolbar-btn" onclick="insertFormat('\n> ','')" title="Quote">"</button>
                    </div>
                    <div class="toolbar-sep"></div>
                    <div class="toolbar-group">
                        <button type="button" class="toolbar-btn" onclick="insertTemplate('frac')" title="Fraction">¬Ω</button>
                        <button type="button" class="toolbar-btn" onclick="insertTemplate('sqrt')" title="Square root">‚àö</button>
                        <button type="button" class="toolbar-btn" onclick="insertTemplate('int')" title="Integral">‚à´</button>
                    </div>
                    <div class="toolbar-sep"></div>
                    <div class="toolbar-group">
                        <button type="button" class="toolbar-btn image-btn" onclick="document.getElementById('imageInput').click()" title="Add Image (or paste/drag)">+ Img</button>
                    </div>
                </div>
                <div class="editor-main">
                    <textarea class="editor-input" id="nodeContent" placeholder="Start writing... (paste or drag images here)" oninput="updatePreview();updateCharCount();"></textarea>
                    <div class="editor-preview" id="previewBox"></div>
                </div>
                <div class="editor-footer">
                    <div class="editor-footer-left">
                        <label title="Include in flashcard review">
                            <input type="checkbox" id="flashcardCheck">
                            Flashcard
                        </label>
                        <div class="image-attach">
                            <input type="file" id="imageInput" accept="image/*" multiple style="display:none">
                            <button type="button" class="image-attach-btn" onclick="document.getElementById('imageInput').click()">+ Image</button>
                            <div class="image-thumbs-mini" id="imageThumbs"></div>
                        </div>
                    </div>
                    <div class="char-count"><span id="charCount">0</span> chars</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-ghost" onclick="closeNodeModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveNode()">Save Note</button>
            </div>
        </div>
    </div>

    <!-- Topic Modal -->
    <div class="modal-overlay" id="topicModal">
        <div class="modal" style="max-width:400px">
            <div class="modal-header">
                <h2>New Topic</h2>
                <button class="modal-close" onclick="closeTopicModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Topic Name</label>
                    <input type="text" id="topicNameInput" placeholder="e.g., Linear Algebra">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-ghost" onclick="closeTopicModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveTopic()">Create</button>
            </div>
        </div>
    </div>

    <!-- Subtopic Modal -->
    <div class="modal-overlay" id="subtopicModal">
        <div class="modal" style="max-width:400px">
            <div class="modal-header">
                <h2>New Subtopic</h2>
                <button class="modal-close" onclick="closeSubtopicModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Subtopic Name</label>
                    <input type="text" id="subtopicNameInput" placeholder="e.g., Vector Spaces">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-ghost" onclick="closeSubtopicModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveSubtopic()">Create</button>
            </div>
        </div>
    </div>

    <!-- Sync Modal -->
    <div class="modal-overlay" id="syncModal">
        <div class="modal" style="max-width:450px">
            <div class="modal-header">
                <h2>‚òÅÔ∏è Cloud Sync</h2>
                <button class="modal-close" onclick="closeSyncModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p style="color:var(--text2); margin-bottom:20px; font-size:13px;">
                    Sync your notes to the cloud with a password.
                </p>
                <div class="form-group">
                    <label>Sync Password</label>
                    <input type="password" id="syncPassword" placeholder="Enter a secure password...">
                </div>
                <div class="form-group">
                    <label>Sync ID</label>
                    <input type="text" id="syncId" placeholder="Leave empty for new, or enter existing ID">
                </div>
                <div style="display:flex; gap:10px; margin-top:20px;">
                    <button class="btn btn-primary" onclick="uploadToCloud()" style="flex:1;">
                        ‚¨ÜÔ∏è Upload
                    </button>
                    <button class="btn btn-ghost" onclick="downloadFromCloud()" style="flex:1;">
                        ‚¨áÔ∏è Download
                    </button>
                </div>
                <div id="syncResult" style="margin-top:15px; padding:12px; background:var(--bg); border-radius:8px; font-size:12px; display:none;"></div>
                <p style="color:var(--text2); margin-top:20px; font-size:11px;">
                    Your Sync ID: <code id="currentSyncId" style="background:var(--bg3);padding:2px 6px;border-radius:4px;">Not set</code>
                </p>

                <hr style="border:none; border-top:1px solid var(--border); margin:25px 0;">

                <h3 style="font-size:14px; margin-bottom:15px;">üíæ Local Backup</h3>
                <p style="color:var(--text2); margin-bottom:15px; font-size:12px;">
                    Download a complete backup file that can restore your entire workspace.
                </p>
                <div style="display:flex; gap:10px;">
                    <button class="btn btn-primary" onclick="downloadLocalBackup()" style="flex:1;">
                        üì• Download Backup
                    </button>
                    <label class="btn btn-ghost" style="flex:1; text-align:center; cursor:pointer;">
                        üì§ Restore Backup
                        <input type="file" id="restoreBackupInput" accept=".json" onchange="restoreFromBackup(event)" style="display:none;">
                    </label>
                </div>
                <p style="color:var(--text2); margin-top:15px; font-size:11px;">
                    Last auto-save: <code id="lastAutoSave" style="background:var(--bg3);padding:2px 6px;border-radius:4px;">Checking...</code>
                </p>
            </div>
        </div>
    </div>

    <!-- Trash Modal -->
    <div class="modal-overlay" id="trashModal">
        <div class="modal" style="max-width:550px; max-height:80vh; display:flex; flex-direction:column;">
            <div class="modal-header">
                <h2>üóëÔ∏è Trash</h2>
                <button class="modal-close" onclick="closeTrashModal()">&times;</button>
            </div>
            <div class="modal-body" style="flex:1; overflow-y:auto;">
                <p style="color:var(--text2); margin-bottom:15px; font-size:13px;">
                    Deleted notes are kept for 30 days before being permanently removed.
                </p>
                <div id="trashList" style="display:flex; flex-direction:column; gap:8px;"></div>
                <div id="trashEmpty" style="text-align:center; padding:40px; color:var(--text2);">
                    Trash is empty
                </div>
            </div>
            <div style="padding:15px; border-top:1px solid var(--border); display:flex; justify-content:flex-end;">
                <button class="btn btn-ghost" onclick="emptyTrash()" style="color:var(--red);">Empty Trash</button>
            </div>
        </div>
    </div>

    <script>
// ==================== ALL JAVASCRIPT INLINED ====================

// ==================== STATE.JS ====================
const State = {
    data: { topics: [], trash: [] },
    currentSubtopic: null,
    selectedNode: null,
    editingNode: null,
    tempImages: [],
    pendingNodePosition: null,
    pan: { x: 0, y: 0 },
    zoom: 1,
    isPanning: false,
    panStart: { x: 0, y: 0 },
    isLinking: false,
    linkStart: null,
    linkLine: null,
    linkingNode: null,
    isDragging: false,
    dragNode: null,
    dragOffset: { x: 0, y: 0 },
    dragStartPos: { x: 0, y: 0 },
    hasDragged: false,
    justFinishedDragging: false,
    currentView: 'notes',
    selectedQuizTopics: new Set(),
    syncId: localStorage.getItem('mindnotes_syncId') || '',
    // For click-to-edit detection
    clickedNode: null,
    clickedNodeEl: null,
    clickStartTime: 0,
    clickStartPos: { x: 0, y: 0 },
    // For link selection
    selectedLink: null,  // { fromId, toId }
    // Undo/Redo stacks
    undoStack: [],
    redoStack: [],
    maxUndoSteps: 50,
    // Flashcard review state
    flashcardSession: {
        active: false,
        cards: [],          // Array of cards to review
        currentIndex: 0,
        showAnswer: false,
        sessionStart: null,
        cardsReviewed: 0,
        correctAnswers: 0,
        reviewHistory: []   // Track reviews for this session
    },
    // Review history (persisted)
    reviewHistory: JSON.parse(localStorage.getItem('mindnotes_reviews') || '[]'),
    // Clipboard for copy/paste notes
    clipboard: null,  // { nodes: [], sourceSubtopic: id }
    // Multi-selection state
    selectedNodes: [],  // Array of selected node ids
    isSelecting: false,
    selectionStart: { x: 0, y: 0 },
    selectionRect: null,
    // Sidebar drag state
    draggedSidebarItem: null,
    draggedSidebarType: null,  // 'topic' or 'subtopic'
    // Delete confirmation state
    lastDeletePress: null
};

// ==================== FSRS SPACED REPETITION ALGORITHM ====================

/**
 * FSRS (Free Spaced Repetition Scheduler) v4.0
 * Modern alternative to SM-2, based on memory research
 * Ported from Python implementation
 */
const FSRS = {
    // Default parameters optimized for general learning
    w: [
        0.4072, 1.1829, 3.1262, 15.4722, 7.2102,
        0.5316, 1.0651, 0.0234, 1.616, 0.1544,
        1.0824, 1.9813, 0.0953, 0.2975, 2.2042,
        0.2407, 2.9466, 0.5034, 0.6567
    ],

    // Card states
    STATE: {
        NEW: 'new',
        LEARNING: 'learning',
        REVIEW: 'review',
        RELEARNING: 'relearning'
    },

    // Ratings: 1=Again, 2=Hard, 3=Good, 4=Easy
    RATING: {
        AGAIN: 1,
        HARD: 2,
        GOOD: 3,
        EASY: 4
    },

    initStability(rating) {
        return Math.max(this.w[rating - 1], 0.1);
    },

    initDifficulty(rating) {
        return Math.min(Math.max(this.w[4] - this.w[5] * (rating - 3), 1), 10);
    },

    forgettingCurve(elapsedDays, stability) {
        return Math.pow(1 + elapsedDays / (9 * stability), -1);
    },

    nextForgetStability(d, s, r) {
        return this.w[11] * Math.pow(d, -this.w[12]) *
            (Math.pow(s + 1, this.w[13]) - 1) *
            Math.exp((1 - r) * this.w[14]);
    },

    nextRecallStability(d, s, r, rating) {
        const hardPenalty = rating === this.RATING.HARD ? 1 : 0;
        const easyBonus = rating === this.RATING.EASY ? 1 : 0;

        return s * (
            1 + Math.exp(this.w[8]) *
            (11 - d) *
            Math.pow(s, -this.w[9]) *
            (Math.exp((1 - r) * this.w[10]) - 1) *
            hardPenalty +
            easyBonus
        );
    },

    nextDifficulty(d, rating) {
        const nextD = d - this.w[6] * (rating - 3);
        const meanReverted = this.w[7] * this.w[4] + (1 - this.w[7]) * nextD;
        return Math.min(Math.max(meanReverted, 1), 10);
    },

    calculateInterval(stability, desiredRetention = 0.9) {
        if (stability <= 0) return 1;
        const interval = stability / desiredRetention *
            (Math.pow(desiredRetention, 1 / 9) - 1) * 9;
        return Math.max(1, Math.round(interval));
    },

    // Initialize FSRS fields for a card (node)
    initCard(node) {
        if (!node.fsrs) {
            node.fsrs = {
                stability: 1.0,
                difficulty: 5.0,
                elapsedDays: 0,
                scheduledDays: 0,
                reps: 0,
                lapses: 0,
                state: this.STATE.NEW,
                lastReview: null,
                dueDate: new Date().toISOString()
            };
        }
        return node;
    },

    // Review a card and return updated FSRS state
    reviewCard(node, rating) {
        this.initCard(node);
        const fsrs = node.fsrs;
        const now = new Date();

        // Calculate elapsed days
        let elapsedDays = 0;
        if (fsrs.lastReview) {
            const lastReview = new Date(fsrs.lastReview);
            elapsedDays = Math.max(0, Math.floor((now - lastReview) / (1000 * 60 * 60 * 24)));
        }

        // Store state before review for history
        const stateBefore = { ...fsrs };

        // Update based on current state
        if (fsrs.state === this.STATE.NEW) {
            fsrs.difficulty = this.initDifficulty(rating);
            fsrs.stability = this.initStability(rating);
            fsrs.reps = 1;

            if (rating === this.RATING.AGAIN) {
                fsrs.state = this.STATE.LEARNING;
                fsrs.scheduledDays = 1;
            } else {
                fsrs.state = this.STATE.REVIEW;
                fsrs.scheduledDays = this.calculateInterval(fsrs.stability);
            }
        } else if (fsrs.state === this.STATE.LEARNING) {
            if (rating === this.RATING.AGAIN) {
                fsrs.scheduledDays = 1;
            } else if (rating === this.RATING.HARD || rating === this.RATING.GOOD) {
                fsrs.state = this.STATE.REVIEW;
                fsrs.scheduledDays = this.calculateInterval(fsrs.stability);
            } else if (rating === this.RATING.EASY) {
                fsrs.state = this.STATE.REVIEW;
                fsrs.scheduledDays = this.calculateInterval(fsrs.stability * 1.3);
            }
            fsrs.reps++;
        } else if (fsrs.state === this.STATE.REVIEW) {
            const retrievability = this.forgettingCurve(elapsedDays, fsrs.stability);

            if (rating === this.RATING.AGAIN) {
                fsrs.lapses++;
                fsrs.state = this.STATE.RELEARNING;
                fsrs.stability = this.nextForgetStability(fsrs.difficulty, fsrs.stability, retrievability);
                fsrs.scheduledDays = 1;
            } else {
                fsrs.stability = this.nextRecallStability(fsrs.difficulty, fsrs.stability, retrievability, rating);
                fsrs.scheduledDays = this.calculateInterval(fsrs.stability);
            }
            fsrs.difficulty = this.nextDifficulty(fsrs.difficulty, rating);
            fsrs.reps++;
            fsrs.elapsedDays = elapsedDays;
        } else if (fsrs.state === this.STATE.RELEARNING) {
            if (rating === this.RATING.AGAIN) {
                fsrs.scheduledDays = 1;
            } else {
                fsrs.state = this.STATE.REVIEW;
                const retrievability = this.forgettingCurve(elapsedDays, fsrs.stability);
                fsrs.stability = this.nextRecallStability(fsrs.difficulty, fsrs.stability, retrievability, rating);
                fsrs.scheduledDays = this.calculateInterval(fsrs.stability);
            }
            fsrs.difficulty = this.nextDifficulty(fsrs.difficulty, rating);
            fsrs.reps++;
            fsrs.elapsedDays = elapsedDays;
        }

        fsrs.lastReview = now.toISOString();
        const dueDate = new Date(now);
        dueDate.setDate(dueDate.getDate() + fsrs.scheduledDays);
        fsrs.dueDate = dueDate.toISOString();

        // Return review log entry
        return {
            nodeId: node.id,
            rating,
            timestamp: now.toISOString(),
            elapsedDays,
            scheduledDays: fsrs.scheduledDays,
            stateBefore: stateBefore.state,
            stateAfter: fsrs.state,
            stabilityBefore: stateBefore.stability,
            stabilityAfter: fsrs.stability
        };
    },

    // Check if a card is due for review
    isDue(node) {
        this.initCard(node);
        const dueDate = new Date(node.fsrs.dueDate);
        return dueDate <= new Date();
    },

    // Get all due cards from all topics
    getDueCards(data) {
        const dueCards = [];
        data.topics.forEach(topic => {
            topic.subtopics.forEach(sub => {
                sub.nodes.forEach(node => {
                    if (node.flashcard) {
                        this.initCard(node);
                        if (this.isDue(node)) {
                            dueCards.push({
                                node,
                                topic: topic.name,
                                subtopic: sub.name,
                                topicId: topic.id,
                                subtopicId: sub.id
                            });
                        }
                    }
                });
            });
        });

        // Sort: new cards first, then by due date
        dueCards.sort((a, b) => {
            if (a.node.fsrs.state === 'new' && b.node.fsrs.state !== 'new') return -1;
            if (a.node.fsrs.state !== 'new' && b.node.fsrs.state === 'new') return 1;
            return new Date(a.node.fsrs.dueDate) - new Date(b.node.fsrs.dueDate);
        });

        return dueCards;
    },

    // Get next interval preview for each rating
    getNextIntervals(node) {
        this.initCard(node);
        const intervals = {};

        [1, 2, 3, 4].forEach(rating => {
            // Simulate the review
            const tempFsrs = JSON.parse(JSON.stringify(node.fsrs));
            const tempNode = { ...node, fsrs: tempFsrs };
            this.reviewCard(tempNode, rating);
            intervals[rating] = tempNode.fsrs.scheduledDays;
        });

        return intervals;
    },

    // Format interval for display
    formatInterval(days) {
        if (days < 1) return '<1d';
        if (days === 1) return '1d';
        if (days < 7) return days + 'd';
        if (days < 30) return Math.round(days / 7) + 'w';
        if (days < 365) return Math.round(days / 30) + 'mo';
        return Math.round(days / 365 * 10) / 10 + 'y';
    }
};

// ==================== UNDO/REDO SYSTEM ====================

function pushToHistory() {
    // Save current state of the selected node's content
    if (!State.selectedNode) return;

    const snapshot = {
        nodeId: State.selectedNode.id,
        content: State.selectedNode.content,
        title: State.selectedNode.title,
        blocks: [...State.contentBlocks]
    };

    State.undoStack.push(snapshot);

    // Limit stack size
    if (State.undoStack.length > State.maxUndoSteps) {
        State.undoStack.shift();
    }

    // Clear redo stack on new change
    State.redoStack = [];
}

function undo() {
    if (State.undoStack.length === 0) return;

    // Save current state to redo stack
    if (State.selectedNode) {
        State.redoStack.push({
            nodeId: State.selectedNode.id,
            content: State.selectedNode.content,
            title: State.selectedNode.title,
            blocks: [...State.contentBlocks]
        });
    }

    // Pop from undo stack
    const snapshot = State.undoStack.pop();

    // Find the node and restore
    if (State.selectedNode && State.selectedNode.id === snapshot.nodeId) {
        State.selectedNode.content = snapshot.content;
        State.selectedNode.title = snapshot.title;
        State.contentBlocks = snapshot.blocks;

        $('detailTitle').value = snapshot.title;
        State.editingBlockIndex = -1;
        renderAllBlocks();
        saveData();
        renderCanvas();
    }
}

function redo() {
    if (State.redoStack.length === 0) return;

    // Save current state to undo stack
    if (State.selectedNode) {
        State.undoStack.push({
            nodeId: State.selectedNode.id,
            content: State.selectedNode.content,
            title: State.selectedNode.title,
            blocks: [...State.contentBlocks]
        });
    }

    // Pop from redo stack
    const snapshot = State.redoStack.pop();

    // Find the node and restore
    if (State.selectedNode && State.selectedNode.id === snapshot.nodeId) {
        State.selectedNode.content = snapshot.content;
        State.selectedNode.title = snapshot.title;
        State.contentBlocks = snapshot.blocks;

        $('detailTitle').value = snapshot.title;
        State.editingBlockIndex = -1;
        renderAllBlocks();
        saveData();
        renderCanvas();
    }
}

// IndexedDB for larger storage (hundreds of MB instead of 5MB)
let db = null;
const DB_NAME = 'mindnotes_db';
const DB_VERSION = 1;
const STORE_NAME = 'data';

function initDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = () => reject(request.error);

        request.onsuccess = () => {
            db = request.result;
            resolve(db);
        };

        request.onupgradeneeded = (e) => {
            const database = e.target.result;
            if (!database.objectStoreNames.contains(STORE_NAME)) {
                database.createObjectStore(STORE_NAME);
            }
        };
    });
}

async function loadData() {
    try {
        if (!db) await initDB();

        const data = await new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readonly');
            const store = tx.objectStore(STORE_NAME);
            const request = store.get('mindnotes2');
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });

        if (data) {
            State.data = data;
            if (!State.data.trash) State.data.trash = [];
            const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
            State.data.trash = State.data.trash.filter(item => item.deletedAt > thirtyDaysAgo);
            console.log('Loaded from IndexedDB, topics:', State.data.topics.length);
        } else {
            // Try migrating from localStorage
            const oldData = localStorage.getItem('mindnotes2');
            if (oldData) {
                State.data = JSON.parse(oldData);
                if (!State.data.trash) State.data.trash = [];
                await saveData();
                localStorage.removeItem('mindnotes2');
                console.log('Migrated from localStorage to IndexedDB');
            } else {
                State.data = createDefaultData();
                console.log('No saved data, using defaults');
            }
        }
    } catch (e) {
        console.error('IndexedDB load error:', e);
        State.data = createDefaultData();
    }

    // Re-render after async load
    renderSidebar();
    if (State.data.topics.length && State.data.topics[0].subtopics.length) {
        selectSubtopic(State.data.topics[0], State.data.topics[0].subtopics[0]);
    }
}

async function saveData() {
    try {
        if (!db) await initDB();

        await new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            const request = store.put(State.data, 'mindnotes2');
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });

        // Data saved successfully
    } catch (e) {
        console.error('IndexedDB save error:', e);
        alert('Error saving: ' + e.message);
    }
}

// Import data from JSON file
function importFromJson() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
            const text = await file.text();
            const importedData = JSON.parse(text);

            // Validate structure
            if (!importedData.topics || !Array.isArray(importedData.topics)) {
                showToast('Invalid data format');
                return;
            }

            // Ask user whether to merge or replace
            const merge = confirm('Merge with existing data?\n\nOK = Merge (add to existing)\nCancel = Replace (delete existing)');

            if (merge) {
                // Merge topics
                importedData.topics.forEach(newTopic => {
                    const existingTopic = State.data.topics.find(t => t.name === newTopic.name);
                    if (existingTopic) {
                        // Merge subtopics
                        newTopic.subtopics.forEach(newSub => {
                            const existingSub = existingTopic.subtopics.find(s => s.name === newSub.name);
                            if (existingSub) {
                                // Add nodes to existing subtopic
                                existingSub.nodes = existingSub.nodes.concat(newSub.nodes);
                            } else {
                                existingTopic.subtopics.push(newSub);
                            }
                        });
                    } else {
                        State.data.topics.push(newTopic);
                    }
                });
            } else {
                // Replace entirely
                State.data = importedData;
                if (!State.data.trash) State.data.trash = [];
            }

            saveData();
            renderSidebar();
            updateFlashcardStats();

            // Select first subtopic
            if (State.data.topics.length && State.data.topics[0].subtopics.length) {
                selectSubtopic(State.data.topics[0], State.data.topics[0].subtopics[0]);
            }

            showToast(`Imported ${importedData.topics.reduce((sum, t) => sum + t.subtopics.reduce((s, sub) => s + sub.nodes.length, 0), 0)} notes!`);
        } catch (err) {
            console.error('Import error:', err);
            showToast('Failed to import: ' + err.message);
        }
    };
    input.click();
}

function createDefaultData() {
    return {
        topics: [{
            id: '1',
            name: 'Linear Algebra',
            subtopics: [
                {
                    id: '1.1',
                    name: 'Vector Spaces',
                    nodes: [
                        {
                            id: 'n1',
                            title: 'Definition',
                            content: 'A **vector space** over field $F$ is a set $V$ with:\n\n- Vector addition\n- Scalar multiplication\n\nSatisfying axioms.',
                            x: 5100,
                            y: 5100,
                            flashcard: true,
                            images: [],
                            links: ['n2']
                        },
                        {
                            id: 'n2',
                            title: 'Basis',
                            content: 'A **basis** is a linearly independent spanning set.\n\n$$\\dim(V) = |\\text{basis}|$$',
                            x: 5300,
                            y: 5080,
                            flashcard: true,
                            images: [],
                            links: []
                        },
                        {
                            id: 'n3',
                            title: 'Linear Independence',
                            content: '$\\vec{v}_1,...,\\vec{v}_n$ are linearly independent if:\n\n$$\\sum c_i\\vec{v}_i = 0 \\implies c_i = 0$$',
                            x: 5200,
                            y: 5220,
                            flashcard: false,
                            images: [],
                            links: ['n1']
                        }
                    ]
                },
                { id: '1.2', name: 'Linear Transformations', nodes: [] },
                { id: '1.3', name: 'Eigenvalues', nodes: [] }
            ]
        }],
        trash: []
    };
}

function getNodeById(nodeId) {
    return State.currentSubtopic?.nodes.find(n => n.id === nodeId);
}

function findNodeLocation(nodeId) {
    for (const topic of State.data.topics) {
        for (const sub of topic.subtopics) {
            if (sub.nodes.some(n => n.id === nodeId)) {
                return { topic, subtopic: sub };
            }
        }
    }
    return null;
}

function generateId() {
    return Date.now().toString();
}

// ==================== UTILS.JS ====================
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function showToast(message, duration = 2500) {
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.classList.add('show'), 10);
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

function $(id) {
    return document.getElementById(id);
}

function formatContent(text) {
    if (!text) return '';

    const latexBlocks = [];
    let processed = String(text)
        .replace(/\$\$([\s\S]*?)\$\$/g, (match) => {
            latexBlocks.push(match);
            return `%%LATEX${latexBlocks.length - 1}%%`;
        })
        .replace(/\$([^\$]+?)\$/g, (match) => {
            latexBlocks.push(match);
            return `%%LATEX${latexBlocks.length - 1}%%`;
        });

    processed = escapeHtml(processed);

    // Apply formatting
    processed = processed
        .replace(/==(.+?)==/g, '<span class="hl-yellow">$1</span>')
        .replace(/::(.+?)::/g, '<span class="hl-green">$1</span>')
        .replace(/~~(.+?)~~/g, '<span class="hl-pink">$1</span>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*([^*]+?)\*/g, '<em>$1</em>')
        .replace(/`([^`]+?)`/g, '<code>$1</code>')
        .replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>')
        .replace(/^- (.+)$/gm, '<li>$1</li>')
        .replace(/^(\d+)\. (.+)$/gm, '<li>$2</li>')
        .replace(/^### (.+)$/gm, '<h4>$1</h4>')
        .replace(/^## (.+)$/gm, '<h3>$1</h3>')
        .replace(/^# (.+)$/gm, '<h2>$1</h2>')
        .replace(/\n/g, '<br>');

    latexBlocks.forEach((block, i) => {
        processed = processed.replace(`%%LATEX${i}%%`, block);
    });
    return processed;
}

function renderMath(element) {
    if (typeof renderMathInElement !== 'undefined') {
        renderMathInElement(element, {
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false }
            ],
            throwOnError: false
        });
    }
}

async function copyToClipboard(text) {
    try {
        await navigator.clipboard.writeText(text);
        return true;
    } catch (e) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        const success = document.execCommand('copy');
        document.body.removeChild(textarea);
        return success;
    }
}

const NODE_COLORS = {
    blue: '#74b9ff',
    purple: '#a29bfe',
    green: '#55efc4',
    orange: '#ffeaa7',
    red: '#ff7675',
    pink: '#fd79a8',
    teal: '#00cec9',
    yellow: '#ffd93d',
    coral: '#ff6b6b',
    lavender: '#b8a9c9',
    mint: '#a8e6cf',
    peach: '#ffb4a2'
};

// ==================== CANVAS.JS ====================
let canvas, canvasWrapper, svg;

function initCanvasRefs() {
    canvas = $('canvas');
    canvasWrapper = $('canvasWrapper');
    svg = $('linksSvg');
}

function renderCanvas() {
    canvas.querySelectorAll('.node').forEach(n => n.remove());
    svg.innerHTML = '';
    if (!State.currentSubtopic) return;

    State.currentSubtopic.nodes.forEach(node => {
        node.links?.forEach(targetId => {
            const target = State.currentSubtopic.nodes.find(n => n.id === targetId);
            if (target) drawLink(node, target);
        });
    });

    State.currentSubtopic.nodes.forEach(node => {
        createNodeElement(node);
    });
}

function renderLinks() {
    svg.innerHTML = '';
    State.currentSubtopic?.nodes.forEach(node => {
        node.links?.forEach(targetId => {
            const target = State.currentSubtopic.nodes.find(n => n.id === targetId);
            if (target) drawLink(node, target);
        });
    });
    if (State.linkLine) svg.appendChild(State.linkLine);
}

// Calculate title font size based on node dimensions
function calculateTitleSize(width, height) {
    const size = Math.max(width || 160, height || 80);
    // Start at 11px, gentle scaling (0.03 factor)
    const fontSize = Math.max(11, 11 + (size - 160) * 0.03);
    return fontSize;
}

// Calculate preview line clamp based on node height
function calculatePreviewLines(height) {
    const h = height || 60;
    // Scale from 2 lines at 60px to 20 lines at 500px+
    if (h < 100) return 2;
    if (h < 150) return 4;
    if (h < 200) return 6;
    if (h < 300) return 10;
    if (h < 400) return 15;
    return 20;
}

function createNodeElement(node) {
    const el = document.createElement('div');
    el.className = 'node' + (State.selectedNode?.id === node.id ? ' selected' : '');
    el.dataset.id = node.id;
    el.style.left = node.x + 'px';
    el.style.top = node.y + 'px';
    if (node.width) el.style.width = node.width + 'px';
    if (node.height) el.style.height = node.height + 'px';

    if (node.color && NODE_COLORS[node.color]) {
        el.style.borderLeftColor = NODE_COLORS[node.color];
        el.style.borderLeftWidth = '4px';
    }

    // Calculate dynamic title size based on node dimensions
    const titleSize = calculateTitleSize(node.width, node.height);

    // Calculate preview lines based on height
    const previewLines = calculatePreviewLines(node.height);

    // Format content with editable formula markers
    const formattedPreview = formatNodePreview(node.content || '');

    el.innerHTML = `
        <div class="node-color-btn" style="background:${NODE_COLORS[node.color] || 'var(--border)'}"></div>
        <div class="color-picker" id="picker-${node.id}">
            <div class="color-opt" style="background:var(--border)" data-c="none"></div>
            ${Object.entries(NODE_COLORS).map(([name, color]) =>
                `<div class="color-opt" style="background:${color}" data-c="${name}"></div>`
            ).join('')}
        </div>
        <div class="node-title" style="font-size:${titleSize}px">${escapeHtml(node.title || 'Untitled')}</div>
        <div class="node-preview" style="-webkit-line-clamp:${previewLines}">${formattedPreview}</div>
        <div class="resize-handle"></div>
    `;

    // Render math in preview
    const preview = el.querySelector('.node-preview');
    renderMath(preview);

    // Make formulas clickable for inline editing
    attachFormulaClickHandlers(el, node);

    attachNodeEventListeners(el, node);
    canvas.appendChild(el);
}

// Format preview with editable formula spans
function formatNodePreview(text) {
    if (!text) return '';

    // Skip leading empty lines
    let trimmedText = String(text).replace(/^[\s\n]*/, '');
    if (!trimmedText) return '';

    let formulaIndex = 0;
    const formulas = [];

    // Replace display math $$...$$ with editable spans
    let processed = trimmedText.replace(/\$\$([\s\S]*?)\$\$/g, (match, inner) => {
        formulas.push({ full: match, inner: inner, display: true });
        return `<span class="editable-formula" data-formula-idx="${formulaIndex++}" data-display="true">$$${inner}$$</span>`;
    });

    // Replace inline math $...$ with editable spans
    processed = processed.replace(/\$([^\$\n]+?)\$/g, (match, inner) => {
        formulas.push({ full: match, inner: inner, display: false });
        return `<span class="editable-formula" data-formula-idx="${formulaIndex++}" data-display="false">$${inner}$</span>`;
    });

    // Now escape and format the rest
    // Split by formula spans, escape non-formula parts
    const parts = processed.split(/(<span class="editable-formula"[^>]*>.*?<\/span>)/g);
    processed = parts.map(part => {
        if (part.startsWith('<span class="editable-formula"')) {
            return part; // Keep formula spans as-is
        }
        // Escape and format non-formula text
        let escaped = escapeHtml(part);
        escaped = escaped
            .replace(/==(.+?)==/g, '<span class="hl-yellow">$1</span>')
            .replace(/::(.+?)::/g, '<span class="hl-green">$1</span>')
            .replace(/~~(.+?)~~/g, '<span class="hl-pink">$1</span>')
            .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*([^*]+?)\*/g, '<em>$1</em>')
            .replace(/`([^`]+?)`/g, '<code>$1</code>')
            .replace(/\n/g, '<br>');
        return escaped;
    }).join('');

    return processed;
}

// Attach click handlers to formula spans
function attachFormulaClickHandlers(el, node) {
    el.querySelectorAll('.editable-formula').forEach(span => {
        span.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            openFormulaEditor(span, node, e);
        });
    });

    // Also handle clicks on rendered KaTeX elements
    el.querySelectorAll('.katex').forEach(katex => {
        katex.style.cursor = 'pointer';
        katex.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            // Find the parent editable-formula span
            const formulaSpan = katex.closest('.editable-formula');
            if (formulaSpan) {
                openFormulaEditor(formulaSpan, node, e);
            }
        });
    });
}

// Open inline formula editor popup
function openFormulaEditor(span, node, event) {
    // Close any existing formula editor
    closeFormulaEditor();

    // Extract the original LaTeX from the span's text content before KaTeX rendered it
    // We need to find it in the original node content
    const formulaIdx = parseInt(span.dataset.formulaIdx);
    const isDisplay = span.dataset.display === 'true';

    // Extract all formulas from original content to get the right one
    const content = node.content || '';
    const formulas = [];

    // Match display math first
    let match;
    const displayRegex = /\$\$([\s\S]*?)\$\$/g;
    while ((match = displayRegex.exec(content)) !== null) {
        formulas.push({ full: match[0], inner: match[1], display: true, start: match.index, end: match.index + match[0].length });
    }

    // Then inline math (avoiding already matched display math)
    const inlineRegex = /\$([^\$\n]+?)\$/g;
    let tempContent = content.replace(/\$\$([\s\S]*?)\$\$/g, m => ' '.repeat(m.length));
    while ((match = inlineRegex.exec(tempContent)) !== null) {
        formulas.push({ full: '$' + content.slice(match.index + 1, match.index + match[0].length - 1) + '$', inner: content.slice(match.index + 1, match.index + match[0].length - 1), display: false, start: match.index, end: match.index + match[0].length });
    }

    // Sort by position
    formulas.sort((a, b) => a.start - b.start);

    if (formulaIdx >= formulas.length) return;
    const formula = formulas[formulaIdx];

    // Create popup
    const popup = document.createElement('div');
    popup.className = 'formula-editor-popup';
    popup.id = 'formulaEditorPopup';

    popup.innerHTML = `
        <textarea id="formulaInput">${formula.inner}</textarea>
        <div class="formula-preview" id="formulaPreview"></div>
        <div class="formula-actions">
            <button class="formula-cancel" onclick="closeFormulaEditor()">Cancel</button>
            <button class="formula-save" id="formulaSaveBtn">Save</button>
        </div>
    `;

    document.body.appendChild(popup);

    // Position near the clicked element
    const rect = span.getBoundingClientRect();
    const popupRect = popup.getBoundingClientRect();

    let left = rect.left;
    let top = rect.bottom + 8;

    // Keep within viewport
    if (left + popupRect.width > window.innerWidth - 20) {
        left = window.innerWidth - popupRect.width - 20;
    }
    if (top + popupRect.height > window.innerHeight - 20) {
        top = rect.top - popupRect.height - 8;
    }

    popup.style.left = Math.max(10, left) + 'px';
    popup.style.top = Math.max(10, top) + 'px';

    const textarea = $('formulaInput');
    const preview = $('formulaPreview');

    // Update preview
    function updateFormulaPreview() {
        const latex = textarea.value;
        const delim = formula.display ? '$$' : '$';
        preview.innerHTML = delim + latex + delim;
        renderMath(preview);
    }

    updateFormulaPreview();
    textarea.addEventListener('input', updateFormulaPreview);
    textarea.focus();
    textarea.select();

    // Save handler
    $('formulaSaveBtn').addEventListener('click', () => {
        const newLatex = textarea.value;
        const delim = formula.display ? '$$' : '$';
        const newFormula = delim + newLatex + delim;

        // Replace in node content
        node.content = content.slice(0, formula.start) + newFormula + content.slice(formula.end);
        saveData();
        renderCanvas();
        closeFormulaEditor();
        showToast('Formula updated');
    });

    // Close on Escape, save on Cmd+Enter
    textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeFormulaEditor();
        } else if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
            $('formulaSaveBtn').click();
        }
    });

    // Close when clicking outside
    setTimeout(() => {
        document.addEventListener('mousedown', handleFormulaClickOutside);
    }, 100);
}

function handleFormulaClickOutside(e) {
    const popup = $('formulaEditorPopup');
    if (popup && !popup.contains(e.target)) {
        closeFormulaEditor();
    }
}

function closeFormulaEditor() {
    const popup = $('formulaEditorPopup');
    if (popup) {
        popup.remove();
    }
    document.removeEventListener('mousedown', handleFormulaClickOutside);
}

function attachNodeEventListeners(el, node) {
    // Color picker button
    el.querySelector('.node-color-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        document.querySelectorAll('.color-picker.open').forEach(p => p.classList.remove('open'));
        el.querySelector('.color-picker').classList.toggle('open');
    });

    // Color options
    el.querySelectorAll('.color-opt').forEach(opt => {
        opt.addEventListener('click', (e) => {
            e.stopPropagation();
            const color = opt.dataset.c;
            node.color = color === 'none' ? null : color;
            saveData();
            renderCanvas();
        });
    });

    // Resize handle
    attachResizeHandler(el, node);

    // Mouse down - track for click detection and start drag
    el.addEventListener('mousedown', (e) => {
        // Skip special UI elements and formulas (they have their own click handlers)
        if (e.target.closest('.node-color-btn') || e.target.closest('.color-picker') ||
            e.target.closest('.resize-handle') || e.target.closest('.editable-formula') ||
            e.target.closest('.katex')) {
            return;
        }

        // Store click info in State for the global mouseup handler
        State.clickedNode = node;
        State.clickedNodeEl = el;
        State.clickStartTime = Date.now();
        State.clickStartPos = { x: e.clientX, y: e.clientY };

        // Cmd/Ctrl + click = linking
        if (e.metaKey || e.ctrlKey) {
            e.preventDefault();
            e.stopPropagation();
            handleLinkingClick(el, node);
            State.clickedNode = null;
            return;
        }

        // If already linking and clicking different node, complete the link
        if (State.linkingNode && State.linkingNode.id !== node.id) {
            e.stopPropagation();
            completeLinking(node);
            State.clickedNode = null;
            return;
        }

        // Setup for potential drag
        State.isDragging = true;
        State.hasDragged = false;
        State.dragNode = node;
        State.dragStartPos = { x: e.clientX, y: e.clientY };

        const rect = canvasWrapper.getBoundingClientRect();
        State.dragOffset.x = (e.clientX - rect.left - State.pan.x) / State.zoom + 5000 - node.x;
        State.dragOffset.y = (e.clientY - rect.top - State.pan.y) / State.zoom + 5000 - node.y;
        el.style.zIndex = 100;
    });

    // Double click to edit - but not on formulas (they have their own click handler)
    el.addEventListener('dblclick', (e) => {
        if (e.target.closest('.node-color-btn') || e.target.closest('.color-picker') ||
            e.target.closest('.resize-handle') || e.target.closest('.editable-formula') ||
            e.target.closest('.katex')) {
            return;
        }
        e.preventDefault();
        e.stopPropagation();
        State.selectedNode = node;
        editSelectedNode();
    });
}

function attachResizeHandler(el, node) {
    const resizeHandle = el.querySelector('.resize-handle');
    const titleEl = el.querySelector('.node-title');
    const previewEl = el.querySelector('.node-preview');

    resizeHandle.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        e.preventDefault();
        const startX = e.clientX;
        const startY = e.clientY;
        const startW = el.offsetWidth;
        const startH = el.offsetHeight;

        function onMove(e) {
            const w = Math.max(120, startW + (e.clientX - startX) / State.zoom);
            const h = Math.max(60, startH + (e.clientY - startY) / State.zoom);
            el.style.width = w + 'px';
            el.style.height = h + 'px';
            node.width = w;
            node.height = h;

            // Update title size dynamically during resize
            const titleSize = calculateTitleSize(w, h);
            titleEl.style.fontSize = titleSize + 'px';

            // Update preview lines dynamically during resize
            const previewLines = calculatePreviewLines(h);
            previewEl.style.webkitLineClamp = previewLines;
        }

        function onUp() {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            saveData();
            renderLinks();
        }

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
    });
}

// handleNodeMousedown removed - logic moved to attachNodeEventListeners

function handleLinkingClick(el, node) {
    if (State.linkingNode && State.linkingNode.id !== node.id) {
        completeLinking(node);
    } else if (!State.linkingNode) {
        State.linkingNode = node;
        el.classList.add('linking-source');
        document.querySelectorAll('.node').forEach(n => {
            if (n.dataset.id !== node.id) n.classList.add('link-target');
        });
        showToast('Cmd+click another note to link');
    }
}

function completeLinking(targetNode) {
    if (!State.linkingNode.links) State.linkingNode.links = [];

    if (!State.linkingNode.links.includes(targetNode.id)) {
        State.linkingNode.links.push(targetNode.id);
        saveData();
        showToast('Link created!');
    } else {
        showToast('Link already exists');
    }

    document.querySelectorAll('.node').forEach(n => n.classList.remove('linking-source', 'link-target'));
    State.linkingNode = null;
    renderCanvas();
}

function cancelLinking() {
    if (State.linkingNode) {
        document.querySelectorAll('.node').forEach(n => n.classList.remove('linking-source', 'link-target'));
        State.linkingNode = null;
        showToast('Linking cancelled');
    }
}

// startDragging removed - logic moved to attachNodeEventListeners

function handleDragMove(e) {
    if (!State.isDragging || !State.dragNode) return;

    const dx = Math.abs(e.clientX - State.dragStartPos.x);
    const dy = Math.abs(e.clientY - State.dragStartPos.y);

    if (dx > 5 || dy > 5) {
        State.hasDragged = true;
    }

    if (State.hasDragged) {
        const rect = canvasWrapper.getBoundingClientRect();
        const newX = (e.clientX - rect.left - State.pan.x) / State.zoom - State.dragOffset.x + 5000;
        const newY = (e.clientY - rect.top - State.pan.y) / State.zoom - State.dragOffset.y + 5000;

        // Calculate the movement delta
        const deltaX = newX - State.dragNode.x;
        const deltaY = newY - State.dragNode.y;

        // Check if dragging a multi-selected node
        const isDraggingMulti = State.selectedNodes.length > 0 &&
                                State.selectedNodes.includes(State.dragNode.id);

        if (isDraggingMulti) {
            // Move all selected nodes together
            State.selectedNodes.forEach(nodeId => {
                const node = State.currentSubtopic?.nodes.find(n => n.id === nodeId);
                if (node) {
                    node.x += deltaX;
                    node.y += deltaY;
                    const el = document.querySelector(`.node[data-id="${nodeId}"]`);
                    if (el) {
                        el.style.left = node.x + 'px';
                        el.style.top = node.y + 'px';
                    }
                }
            });
        } else {
            // Single node drag
            State.dragNode.x = newX;
            State.dragNode.y = newY;
            const el = document.querySelector(`.node[data-id="${State.dragNode.id}"]`);
            if (el) {
                el.style.left = newX + 'px';
                el.style.top = newY + 'px';
            }
        }

        renderLinks();
    }
}

function endDragging() {
    if (State.isDragging) {
        State.justFinishedDragging = State.hasDragged;
        State.isDragging = false;

        if (State.hasDragged) {
            saveData();
        }
        State.hasDragged = false;
        State.dragNode = null;
    }
}

function drawLink(from, to) {
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    group.style.cursor = 'pointer';
    group.style.pointerEvents = 'all';
    group.dataset.fromId = from.id;
    group.dataset.toId = to.id;

    const fromW = from.width || 160;
    const fromH = from.height || 70;
    const toW = to.width || 160;
    const toH = to.height || 70;

    const x1 = from.x + fromW / 2;
    const y1 = from.y + fromH / 2;
    const x2 = to.x + toW / 2;
    const y2 = to.y + toH / 2;

    // Check if this link is selected
    const isSelected = State.selectedLink &&
        ((State.selectedLink.fromId === from.id && State.selectedLink.toId === to.id) ||
         (State.selectedLink.fromId === to.id && State.selectedLink.toId === from.id));

    // Invisible wide line for easier clicking (hit area)
    const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    hitArea.setAttribute('x1', x1);
    hitArea.setAttribute('y1', y1);
    hitArea.setAttribute('x2', x2);
    hitArea.setAttribute('y2', y2);
    hitArea.setAttribute('stroke', 'transparent');
    hitArea.setAttribute('stroke-width', '15');
    group.appendChild(hitArea);

    // Visible line
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('stroke', isSelected ? '#e74c3c' : '#6c5ce7');
    line.setAttribute('stroke-width', isSelected ? '3' : '1.5');
    line.setAttribute('stroke-opacity', isSelected ? '1' : '0.6');
    group.appendChild(line);

    // Click handler to select link
    group.addEventListener('click', (e) => {
        e.stopPropagation();
        selectLink(from.id, to.id);
    });

    svg.appendChild(group);
}

function selectLink(fromId, toId) {
    // Deselect node if any
    State.selectedNode = null;
    // Toggle selection if clicking same link
    if (State.selectedLink &&
        ((State.selectedLink.fromId === fromId && State.selectedLink.toId === toId) ||
         (State.selectedLink.fromId === toId && State.selectedLink.toId === fromId))) {
        State.selectedLink = null;
    } else {
        State.selectedLink = { fromId, toId };
    }
    renderCanvas();
    showToast(State.selectedLink ? 'Link selected - press Delete to remove' : 'Link deselected');
}

function deleteSelectedLink() {
    if (!State.selectedLink || !State.currentSubtopic) return;

    const { fromId, toId } = State.selectedLink;
    const fromNode = State.currentSubtopic.nodes.find(n => n.id === fromId);
    const toNode = State.currentSubtopic.nodes.find(n => n.id === toId);

    // Remove link from both nodes (links can be stored in either direction)
    if (fromNode && fromNode.links) {
        fromNode.links = fromNode.links.filter(id => id !== toId);
    }
    if (toNode && toNode.links) {
        toNode.links = toNode.links.filter(id => id !== fromId);
    }

    State.selectedLink = null;
    saveData();
    renderCanvas();
    showToast('Link deleted');
}

function startPanning(e) {
    State.isPanning = true;
    State.panStart.x = e.clientX - State.pan.x;
    State.panStart.y = e.clientY - State.pan.y;
    canvas.classList.add('grabbing');
}

function handlePanMove(e) {
    if (!State.isPanning) return;
    State.pan.x = e.clientX - State.panStart.x;
    State.pan.y = e.clientY - State.panStart.y;
    updateTransform();
}

function endPanning() {
    if (State.isPanning) {
        State.isPanning = false;
        canvas.classList.remove('grabbing');
    }
}

function zoomIn() {
    State.zoom = Math.min(State.zoom * 1.2, 3);
    updateTransform();
}

function zoomOut() {
    State.zoom = Math.max(State.zoom / 1.2, 0.2);
    updateTransform();
}

function handleWheelZoom(e) {
    e.preventDefault();
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.min(Math.max(State.zoom * delta, 0.2), 3);

    const rect = canvasWrapper.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    State.pan.x = mx - (mx - State.pan.x) * (newZoom / State.zoom);
    State.pan.y = my - (my - State.pan.y) * (newZoom / State.zoom);
    State.zoom = newZoom;

    updateTransform();
}

function updateTransform() {
    canvas.style.transform = `translate(${State.pan.x}px, ${State.pan.y}px) scale(${State.zoom})`;
    $('canvasBg').style.backgroundPosition = `${State.pan.x}px ${State.pan.y}px`;
    $('canvasBg').style.backgroundSize = `${40 * State.zoom}px ${40 * State.zoom}px`;
    $('zoomLevel').textContent = Math.round(State.zoom * 100) + '%';
}

function fitView() {
    if (!State.currentSubtopic?.nodes.length) {
        State.pan = { x: 0, y: 0 };
        State.zoom = 1;
        updateTransform();
        return;
    }

    const nodes = State.currentSubtopic.nodes;
    const minX = Math.min(...nodes.map(n => n.x));
    const maxX = Math.max(...nodes.map(n => n.x)) + 200;
    const minY = Math.min(...nodes.map(n => n.y));
    const maxY = Math.max(...nodes.map(n => n.y)) + 60;

    const rect = canvasWrapper.getBoundingClientRect();
    const padding = 100;

    const scaleX = (rect.width - padding * 2) / (maxX - minX);
    const scaleY = (rect.height - padding * 2) / (maxY - minY);
    State.zoom = Math.min(scaleX, scaleY, 1.5);
    State.zoom = Math.max(State.zoom, 0.3);

    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;

    State.pan.x = rect.width / 2 - (centerX - 5000) * State.zoom;
    State.pan.y = rect.height / 2 - (centerY - 5000) * State.zoom;

    updateTransform();
}

function handleCanvasClick(e) {
    if (State.linkingNode) {
        cancelLinking();
        return;
    }

    if (!State.currentSubtopic) {
        alert('Select a subtopic first');
        return;
    }

    const rect = canvasWrapper.getBoundingClientRect();
    const x = (e.clientX - rect.left - State.pan.x) / State.zoom + 5000;
    const y = (e.clientY - rect.top - State.pan.y) / State.zoom + 5000;

    State.pendingNodePosition = { x, y };
    openNodeModal();
}

// ==================== EDITOR.JS ====================
function openNodeModal() {
    State.editingNode = null;
    State.tempImages = [];

    $('nodeTitle').value = '';
    $('nodeTitle').placeholder = 'New Note';
    $('nodeContent').value = '';
    $('flashcardCheck').checked = false;
    $('imageThumbs').innerHTML = '';
    $('previewBox').innerHTML = '';
    $('charCount').textContent = '0';
    $('nodeModal').classList.add('visible');
    $('nodeTitle').focus();
}

function editSelectedNode() {
    if (!State.selectedNode) return;
    // Open detail panel in view mode, user can click Edit to enter edit mode
    openDetail(State.selectedNode);
}

function closeNodeModal() {
    $('nodeModal').classList.remove('visible');
    State.editingNode = null;
    State.tempImages = [];
}

async function saveNode() {
    const title = $('nodeTitle').value.trim();
    const content = $('nodeContent').value;
    const flashcard = $('flashcardCheck').checked;

    if (!title) {
        alert('Enter a title');
        return;
    }

    if (!State.editingNode && !State.currentSubtopic) {
        alert('Please select a subtopic first');
        return;
    }

    if (State.editingNode) {
        State.editingNode.title = title;
        State.editingNode.content = content;
        State.editingNode.flashcard = flashcard;
        State.editingNode.images = State.tempImages;
    } else {
        let x, y;
        if (State.pendingNodePosition) {
            x = State.pendingNodePosition.x;
            y = State.pendingNodePosition.y;
        } else {
            const rect = canvasWrapper.getBoundingClientRect();
            x = 5000 + (rect.width / 2 - State.pan.x) / State.zoom + (Math.random() - 0.5) * 100;
            y = 5000 + (rect.height / 2 - State.pan.y) / State.zoom + (Math.random() - 0.5) * 100;
        }

        State.currentSubtopic.nodes.push({
            id: generateId(),
            title,
            content,
            flashcard,
            images: State.tempImages,
            links: [],
            x,
            y
        });

        State.pendingNodePosition = null;
    }

    await saveData();
    showToast('Note saved');
    closeNodeModal();
    closeDetail();
    renderCanvas();
    renderSidebar();
}

function deleteSelectedNode() {
    if (!State.selectedNode) return;

    const location = findNodeLocation(State.selectedNode.id);

    State.data.trash.push({
        ...State.selectedNode,
        deletedAt: Date.now(),
        fromTopic: location?.topic.id,
        fromSubtopic: location?.subtopic.id
    });

    State.currentSubtopic.nodes.forEach(n => {
        n.links = n.links?.filter(id => id !== State.selectedNode.id) || [];
    });

    State.currentSubtopic.nodes = State.currentSubtopic.nodes.filter(n => n.id !== State.selectedNode.id);

    saveData();
    closeDetail();
    State.selectedNode = null;
    renderCanvas();
    renderSidebar();
    updateTrashCount();
    showToast('Note moved to trash');
}

function insertFormat(before, after) {
    const textarea = $('nodeContent');
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = textarea.value;
    const selected = text.substring(start, end) || 'text';

    textarea.value = text.substring(0, start) + before + selected + after + text.substring(end);
    textarea.focus();
    textarea.setSelectionRange(start + before.length, start + before.length + selected.length);

    updatePreview();
    updateCharCount();
}

function insertHighlight(color) {
    const markers = {
        yellow: ['==', '=='],
        green: ['::', '::'],
        pink: ['~~', '~~']
    };
    const [open, close] = markers[color];
    insertFormat(open, close);
}

function insertTemplate(type) {
    const templates = {
        frac: '\\frac{num}{den}',
        sqrt: '\\sqrt{x}',
        int: '\\int_{a}^{b} f(x) \\, dx',
        matrix: '\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}'
    };
    insertFormat('$' + templates[type], '$');
}

function updatePreview() {
    const text = $('nodeContent').value;
    const box = $('previewBox');
    const format = $('formatSelector').value;

    if (format === 'obsidian') {
        // Obsidian format: show formatted text ready for Obsidian
        box.innerHTML = formatForObsidian(text);
    } else {
        // LaTeX format: render with KaTeX
        box.innerHTML = formatContent(text);
        renderMath(box);
    }

    // Show attached images in preview
    if (State.tempImages && State.tempImages.length > 0) {
        const imagesHtml = State.tempImages.map((img, i) =>
            `<div class="preview-image"><img src="${img}" alt="Attached image ${i+1}"></div>`
        ).join('');
        box.innerHTML += `<div class="preview-images">${imagesHtml}</div>`;
    }
}

/**
 * Format content for Obsidian preview with LIVE math rendering
 * Supports both LaTeX ($$...$$) and Obsidian ($\n...\n$) display math
 * Renders math with KaTeX for live preview
 */
function formatForObsidian(text) {
    // Store all math to protect from formatting
    const mathBlocks = [];

    // Handle $$...$$ display math (LaTeX style)
    let result = text.replace(/\$\$([\s\S]*?)\$\$/g, (match, content) => {
        mathBlocks.push({ type: 'display', content: content.trim() });
        return `%%MATH${mathBlocks.length - 1}%%`;
    });

    // Handle $ on own line display math (Obsidian style)
    result = result.replace(/\n\$\n([\s\S]*?)\n\$(?=\n|$)/g, (match, content) => {
        mathBlocks.push({ type: 'display', content: content.trim() });
        return `\n%%MATH${mathBlocks.length - 1}%%\n`;
    });

    // Handle display math at start of text (Obsidian style)
    result = result.replace(/^\$\n([\s\S]*?)\n\$(?=\n|$)/g, (match, content) => {
        mathBlocks.push({ type: 'display', content: content.trim() });
        return `%%MATH${mathBlocks.length - 1}%%\n`;
    });

    // Handle inline math $...$
    result = result.replace(/\$([^\$\n]+?)\$/g, (match, content) => {
        mathBlocks.push({ type: 'inline', content: content });
        return `%%MATH${mathBlocks.length - 1}%%`;
    });

    // Format highlights
    result = result.replace(/::(.+?)::/g, '==$1==');
    result = result.replace(/~~(.+?)~~/g, '==$1==');

    // Escape HTML
    result = escapeHtml(result);

    // Format markdown
    result = result
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*([^\*]+?)\*/g, '<em>$1</em>')
        .replace(/`([^`]+?)`/g, '<code>$1</code>')
        .replace(/==(.+?)==/g, '<mark>$1</mark>')
        .replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>')
        .replace(/^- (.+)$/gm, '<li>$1</li>')
        .replace(/^(\d+)\. (.+)$/gm, '<li>$2</li>')
        .replace(/^### (.+)$/gm, '<h4>$1</h4>')
        .replace(/^## (.+)$/gm, '<h3>$1</h3>')
        .replace(/^# (.+)$/gm, '<h2>$1</h2>');

    // Restore math with KaTeX rendering
    mathBlocks.forEach((block, i) => {
        try {
            if (typeof katex !== 'undefined') {
                const rendered = katex.renderToString(block.content, {
                    displayMode: block.type === 'display',
                    throwOnError: false
                });
                if (block.type === 'display') {
                    result = result.replace(`%%MATH${i}%%`, `<div class="katex-display">${rendered}</div>`);
                } else {
                    result = result.replace(`%%MATH${i}%%`, rendered);
                }
            } else {
                // Fallback if KaTeX not loaded
                result = result.replace(`%%MATH${i}%%`, `<code>$${escapeHtml(block.content)}$</code>`);
            }
        } catch (e) {
            result = result.replace(`%%MATH${i}%%`, `<code class="math-error">$${escapeHtml(block.content)}$</code>`);
        }
    });

    // Convert newlines to <br>
    result = result.replace(/\n/g, '<br>');

    return result;
}

function updateCharCount() {
    const count = $('nodeContent').value.length;
    $('charCount').textContent = count;
}

function initImageInput() {
    const imageInput = $('imageInput');
    if (imageInput) {
        imageInput.onchange = (e) => handleFiles(e.target.files);
    }

    // Add paste image support to the editor textarea
    const textarea = $('nodeContent');
    if (textarea) {
        textarea.addEventListener('paste', (e) => {
            const items = e.clipboardData?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    e.preventDefault();
                    const file = item.getAsFile();
                    if (file) {
                        handleFiles([file]);
                        showToast('Image pasted');
                    }
                    break;
                }
            }
        });
    }

    // Add drag and drop support for images in the modal
    const editorWrapper = document.querySelector('#nodeModal .editor-wrapper');
    if (editorWrapper) {
        editorWrapper.addEventListener('dragover', (e) => {
            e.preventDefault();
            editorWrapper.classList.add('drag-over');
        });
        editorWrapper.addEventListener('dragleave', () => {
            editorWrapper.classList.remove('drag-over');
        });
        editorWrapper.addEventListener('drop', (e) => {
            e.preventDefault();
            editorWrapper.classList.remove('drag-over');
            const files = e.dataTransfer?.files;
            if (files && files.length) {
                handleFiles(files);
            }
        });
    }
}

function handleFiles(files) {
    Array.from(files).forEach(file => {
        if (!file.type.startsWith('image/')) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            State.tempImages.push(e.target.result);
            renderImageThumbs();
        };
        reader.readAsDataURL(file);
    });
}

function renderImageThumbs() {
    const container = $('imageThumbs');
    container.innerHTML = State.tempImages.map((img, i) =>
        `<div class="image-thumb-mini" onclick="removeImage(${i})"><img src="${escapeHtml(img)}"></div>`
    ).join('');
    // Update preview to show images
    updatePreview();
}

function removeImage(index) {
    State.tempImages.splice(index, 1);
    renderImageThumbs();
}

// ==================== INLINE IMAGES ====================

function triggerDetailImageUpload() {
    if (!State.selectedNode) {
        showToast('Select a note first');
        return;
    }
    const input = $('detailImageInput');
    if (input) {
        input.click();
    } else {
        showToast('Image input not found');
    }
}

function initDetailImageInput() {
    const input = $('detailImageInput');
    if (input) {
        input.onchange = (e) => {
            const files = e.target.files;
            if (!files || files.length === 0) return;

            Array.from(files).forEach(file => {
                if (!file.type.startsWith('image/')) return;

                const reader = new FileReader();
                reader.onload = (ev) => {
                    insertInlineImage(ev.target.result);
                };
                reader.readAsDataURL(file);
            });

            input.value = ''; // Reset for next use
        };
    }
}

function insertInlineImage(base64Data) {
    if (!State.selectedNode) {
        showToast('Select a note first');
        return;
    }

    // Store image in node's images array (simple format)
    if (!State.selectedNode.images) {
        State.selectedNode.images = [];
    }

    // Convert object format to array if needed
    if (!Array.isArray(State.selectedNode.images)) {
        const oldImages = Object.values(State.selectedNode.images);
        State.selectedNode.images = oldImages;
    }

    // Add the new image
    State.selectedNode.images.push(base64Data);

    // Save
    saveData();
    renderCanvas();

    // Force refresh the detail panel to show the image immediately
    setTimeout(() => {
        renderObsidianPreview();
    }, 50);

    showToast('Image added!');
}

function renderInlineImages(html, node) {
    if (!node || !node.images) return html;

    let result = html;

    // Handle object format with markers
    if (typeof node.images === 'object' && !Array.isArray(node.images)) {
        result = result.replace(/!\[img:([^\]]+)\]/g, (match, imgId) => {
            const imgData = node.images[imgId];
            if (imgData) {
                return `<img src="${imgData}" class="inline-image" data-img-id="${imgId}">`;
            }
            return match;
        });
    }

    // Handle array format - show images with controls
    if (Array.isArray(node.images) && node.images.length > 0) {
        const imagesHtml = node.images.map((img, i) => {
            // Check if image has stored width
            const width = node.imageWidths?.[i] || null;
            const widthStyle = width ? `width:${width}px;` : '';
            const canMoveUp = i > 0;
            const canMoveDown = i < node.images.length - 1;
            return `
                <div class="attached-image" data-img-index="${i}" onclick="selectImage(event, ${i})">
                    <img src="${img}" alt="Image ${i+1}" style="${widthStyle}">
                    <div class="image-controls">
                        ${canMoveUp ? `<button onclick="event.stopPropagation(); moveImage(${i}, -1)" title="Move up">‚Üë</button>` : ''}
                        ${canMoveDown ? `<button onclick="event.stopPropagation(); moveImage(${i}, 1)" title="Move down">‚Üì</button>` : ''}
                        <button onclick="event.stopPropagation(); deleteImage(${i})" title="Delete">√ó</button>
                    </div>
                    <div class="resize-handle" onmousedown="startImageResize(event, ${i})"></div>
                </div>
            `;
        }).join('');
        result += `<div class="attached-images">${imagesHtml}</div>`;
    }

    return result;
}

function selectImage(event, index) {
    event.stopPropagation();
    // Deselect all images first
    document.querySelectorAll('.attached-image').forEach(el => el.classList.remove('selected'));
    // Select this one
    event.currentTarget.classList.add('selected');
    State.selectedImageIndex = index;
}

function deselectAllImages() {
    document.querySelectorAll('.attached-image').forEach(el => el.classList.remove('selected'));
    State.selectedImageIndex = -1;
}

function deleteImage(index) {
    if (!State.selectedNode || !State.selectedNode.images) return;

    State.selectedNode.images.splice(index, 1);
    if (State.selectedNode.imageWidths) {
        State.selectedNode.imageWidths.splice(index, 1);
    }

    saveData();
    renderCanvas();
    renderObsidianPreview();
    showToast('Image deleted');
}

function moveImage(index, direction) {
    if (!State.selectedNode || !State.selectedNode.images) return;

    const newIndex = index + direction;
    if (newIndex < 0 || newIndex >= State.selectedNode.images.length) return;

    // Swap images
    const images = State.selectedNode.images;
    [images[index], images[newIndex]] = [images[newIndex], images[index]];

    // Swap widths too if they exist
    if (State.selectedNode.imageWidths) {
        const widths = State.selectedNode.imageWidths;
        [widths[index], widths[newIndex]] = [widths[newIndex], widths[index]];
    }

    saveData();
    renderCanvas();
    renderObsidianPreview();
}

function startImageResize(event, index) {
    event.preventDefault();
    event.stopPropagation();

    const imageEl = event.target.parentElement.querySelector('img');
    const startX = event.clientX;
    const startWidth = imageEl.offsetWidth;

    function onMove(e) {
        const newWidth = Math.max(50, startWidth + (e.clientX - startX));
        imageEl.style.width = newWidth + 'px';
    }

    function onUp(e) {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);

        // Save the width
        if (!State.selectedNode.imageWidths) {
            State.selectedNode.imageWidths = [];
        }
        State.selectedNode.imageWidths[index] = imageEl.offsetWidth;
        saveData();
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
}

function startImageDrag(e, imgId) {
    e.dataTransfer.setData('text/plain', imgId);
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');
    State.draggingImageId = imgId;

    // Show drop zones
    document.querySelectorAll('.live-block').forEach(block => {
        if (!block.querySelector('.block-editor')) {
            const dropZone = document.createElement('div');
            dropZone.className = 'image-drop-zone';
            dropZone.ondragover = (ev) => {
                ev.preventDefault();
                dropZone.classList.add('active');
            };
            dropZone.ondragleave = () => dropZone.classList.remove('active');
            dropZone.ondrop = (ev) => dropImageInBlock(ev, parseInt(block.dataset.index));
            block.insertBefore(dropZone, block.firstChild);
        }
    });
}

function endImageDrag(e) {
    e.target.classList.remove('dragging');
    State.draggingImageId = null;

    // Remove drop zones
    document.querySelectorAll('.image-drop-zone').forEach(z => z.remove());
}

function dropImageInBlock(e, blockIndex) {
    e.preventDefault();
    const imgId = e.dataTransfer.getData('text/plain');
    if (!imgId || !State.selectedNode) return;

    pushToHistory();

    const imageMarker = `![img:${imgId}]`;

    // Remove image from old position in all blocks
    State.contentBlocks = State.contentBlocks.map(block =>
        block.replace(new RegExp(`\\n?!\\[img:${imgId}\\]\\n?`, 'g'), '')
    ).filter(block => block.trim());

    // Insert at new block position
    if (blockIndex < State.contentBlocks.length) {
        State.contentBlocks[blockIndex] = imageMarker + '\n' + State.contentBlocks[blockIndex];
    } else {
        State.contentBlocks.push(imageMarker);
    }

    autoSaveContent();
    renderAllBlocks();
}

function selectNode(node) {
    State.selectedNode = node;
    State.selectedLink = null;  // Clear link selection
    renderCanvas();
    openDetail(node);  // Open detail panel in view mode (not the modal)
}

function openNodeEditor(node) {
    State.editingNode = node;

    // Handle images safely
    let images = [];
    if (node.images) {
        if (Array.isArray(node.images)) {
            images = node.images;
        } else if (typeof node.images === 'object') {
            images = Object.values(node.images);
        }
    }
    State.tempImages = [...images];

    $('nodeTitle').value = node.title;
    $('nodeTitle').placeholder = 'Untitled';
    $('nodeContent').value = node.content || '';
    $('flashcardCheck').checked = node.flashcard || false;

    renderImageThumbs();
    updatePreview();
    updateCharCount();

    $('nodeModal').classList.add('visible');
    $('nodeContent').focus();
}

// Block-based live editor state
State.editingBlockIndex = -1;
State.contentBlocks = [];

function openDetail(node) {
    const panel = $('detailPanel');
    panel.classList.add('open');
    panel.classList.add('view-mode');  // Always open in view mode
    State.editingBlockIndex = -1;
    State.isEditingFullContent = false;

    // Set fields
    $('detailTitle').value = node.title;
    $('detailTitleDisplay').textContent = node.title || 'Untitled';
    $('detailFlashcard').checked = node.flashcard || false;

    // Update flashcard badge visibility
    $('flashcardBadge').style.display = node.flashcard ? 'inline-block' : 'none';

    // Update FSRS stats display
    updateFsrsStatsDisplay(node);

    // Set content and render with Obsidian-style preview
    State.currentContent = node.content || '';
    State.contentBlocks = [State.currentContent];

    // Update editor textarea (for when entering edit mode)
    $('detailContentEditor').value = State.currentContent;

    renderObsidianPreview();

    // Update links list
    const linksList = $('linksListDetail');
    const linkedNodes = [
        ...node.links.map(id => State.currentSubtopic.nodes.find(n => n.id === id)).filter(Boolean),
        ...State.currentSubtopic.nodes.filter(n => n.links?.includes(node.id))
    ];
    const unique = [...new Map(linkedNodes.map(n => [n.id, n])).values()];

    linksList.innerHTML = unique.length
        ? unique.map(n =>
            `<span class="link-item" onclick="selectNode(State.currentSubtopic.nodes.find(x=>x.id==='${n.id}'))">${escapeHtml(n.title)}</span>`
        ).join('')
        : '<span style="color:var(--text2)">No links</span>';
}

function updateFsrsStatsDisplay(node) {
    const statsDiv = $('detailFsrsStats');

    if (!node.flashcard) {
        statsDiv.style.display = 'none';
        return;
    }

    statsDiv.style.display = 'flex';
    FSRS.initCard(node);

    const fsrs = node.fsrs;
    $('fsrsState').textContent = fsrs.state.charAt(0).toUpperCase() + fsrs.state.slice(1);

    // Format due date
    const dueDate = new Date(fsrs.dueDate);
    const now = new Date();
    const diffDays = Math.floor((dueDate - now) / (1000 * 60 * 60 * 24));

    let dueText;
    if (diffDays < 0) {
        dueText = Math.abs(diffDays) + 'd overdue';
    } else if (diffDays === 0) {
        dueText = 'Due today';
    } else {
        dueText = 'In ' + FSRS.formatInterval(diffDays);
    }
    $('fsrsDue').textContent = dueText;

    $('fsrsStability').textContent = fsrs.stability.toFixed(1);
    $('fsrsReps').textContent = fsrs.reps;
}

function toggleFlashcardDetail() {
    if (!State.selectedNode) return;
    State.selectedNode.flashcard = $('detailFlashcard').checked;
    updateFsrsStatsDisplay(State.selectedNode);
    saveData();
    renderCanvas();
    updateFlashcardStats();
}

function parseAndRenderBlocks(content) {
    if (!content || !content.trim()) {
        State.contentBlocks = [''];
        renderAllBlocks();
        return;
    }

    // Split by sentences, but NEVER split inside math
    // Track math state: 0 = not in math, 1 = in $...$, 2 = in $$...$$, 3 = in Obsidian $\n...\n$
    const blocks = [];
    let current = '';
    let inMath = 0;
    let i = 0;

    while (i < content.length) {
        const char = content[i];
        const next = content[i + 1] || '';
        const next2 = content.slice(i, i + 2);

        // Check for math delimiters
        if (inMath === 0) {
            // Not in math - check for opening
            if (next2 === '$$') {
                current += '$$';
                inMath = 2;
                i += 2;
                continue;
            } else if (char === '$') {
                // Check if this is Obsidian-style display math ($ on own line)
                const prevChar = content[i - 1] || '\n';
                if (prevChar === '\n' && (next === '\n' || next === '\r')) {
                    inMath = 3; // Obsidian display math
                } else {
                    inMath = 1; // Inline math
                }
                current += char;
                i++;
                continue;
            }
        } else if (inMath === 2) {
            // In $$...$$ - look for closing $$
            if (next2 === '$$') {
                current += '$$';
                inMath = 0;
                i += 2;
                continue;
            }
        } else if (inMath === 1) {
            // In $...$ inline - look for closing $
            if (char === '$' && next !== '$') {
                current += char;
                inMath = 0;
                i++;
                continue;
            }
        } else if (inMath === 3) {
            // In Obsidian $\n...\n$ - look for $ on its own line
            if (char === '$' && next !== '$') {
                const prevChar = content[i - 1] || '';
                if (prevChar === '\n') {
                    current += char;
                    inMath = 0;
                    i++;
                    continue;
                }
            }
        }

        current += char;

        // Only check for sentence splits when NOT in math
        if (inMath === 0 && (char === '.' || char === '!' || char === '?')) {
            // Check if followed by whitespace (potential split point)
            if (next === ' ' || next === '\n') {
                // Look ahead past whitespace to see if there's math starting
                let lookAhead = i + 1;
                while (lookAhead < content.length && (content[lookAhead] === ' ' || content[lookAhead] === '\n')) {
                    lookAhead++;
                }
                const afterWs = content.slice(lookAhead, lookAhead + 2);

                // If math starts after whitespace, include it in this block
                if (afterWs === '$$' || (content[lookAhead] === '$' && content[lookAhead + 1] !== '$')) {
                    // Don't split - let the math be included in next iteration
                } else {
                    // Normal split
                    if (current.trim()) blocks.push(current.trim());
                    current = '';
                    i++; // skip the space/newline
                }
            }
        }
        i++;
    }

    // Don't forget remaining content
    if (current.trim()) {
        blocks.push(current.trim());
    }

    State.contentBlocks = blocks.length ? blocks : [''];
    renderObsidianPreview();
}

// Render the preview pane with formatted content
State.currentContent = '';
State.isEditingFullContent = false;

function renderObsidianPreview() {
    const container = $('detailPreview');
    const content = State.currentContent || State.contentBlocks.join('\n') || '';
    const format = $('detailFormatSelector')?.value || 'latex';

    // Render content (preview only - editing is done in the editor pane)
    let html = '';
    if (format === 'chatgpt') {
        // Pre-process ChatGPT format, then make editable
        const cleaned = content
            .replace(/\\\[/g, '$$')
            .replace(/\\\]/g, '$$')
            .replace(/\\\(/g, '$')
            .replace(/\\\)/g, '$');
        html = formatContentWithEditableFormulas(cleaned);
    } else {
        html = formatContentWithEditableFormulas(content);
    }

    // Render inline images
    html = renderInlineImages(html, State.selectedNode);

    container.innerHTML = `
        <div class="live-preview-content">${html || '<span class="detail-text empty-placeholder" data-seg-idx="0" style="color:var(--text2);cursor:text;">Click here to start writing...</span>'}</div>
    `;

    const previewContent = container.querySelector('.live-preview-content');

    // Always render math for all formats
    renderMath(previewContent);

    // Attach click handlers to formulas and text
    attachDetailFormulaHandlers(previewContent);
}

function startFullContentEdit() {
    State.isEditingFullContent = true;
    pushToHistory();
    renderObsidianPreview();
}

// Format content with editable segments (formulas and text) for detail panel
function formatContentWithEditableFormulas(text) {
    if (!text) return '';

    // Parse content into segments: text and formulas
    const segments = parseContentSegments(text);

    // Build HTML with editable spans for each segment
    let html = '';
    segments.forEach((seg, idx) => {
        if (seg.type === 'formula') {
            // Formula segment - render with KaTeX markers
            html += `<span class="detail-formula" data-seg-idx="${idx}" data-display="${seg.display}">`;
            html += seg.display ? `$$${seg.inner}$$` : `$${seg.inner}$`;
            html += `</span>`;
        } else {
            // Text segment - make it editable, keep inline
            let formatted = escapeHtml(seg.text);
            formatted = formatted
                .replace(/==(.+?)==/g, '<span class="hl-yellow">$1</span>')
                .replace(/::(.+?)::/g, '<span class="hl-green">$1</span>')
                .replace(/~~(.+?)~~/g, '<span class="hl-pink">$1</span>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*([^*]+?)\*/g, '<em>$1</em>')
                .replace(/`([^`]+?)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');

            if (seg.text.trim()) {
                html += `<span class="detail-text" data-seg-idx="${idx}">${formatted}</span>`;
            } else {
                html += formatted; // Empty/whitespace - don't wrap
            }
        }
    });

    return html;
}

// Parse content into segments of text and formulas with positions
function parseContentSegments(text) {
    const segments = [];
    let lastEnd = 0;

    // Find all formulas first
    const formulas = [];

    // Display math $$...$$
    const displayRegex = /\$\$([\s\S]*?)\$\$/g;
    let match;
    while ((match = displayRegex.exec(text)) !== null) {
        formulas.push({
            type: 'formula',
            display: true,
            inner: match[1],
            start: match.index,
            end: match.index + match[0].length
        });
    }

    // Inline math $...$
    const inlineRegex = /\$([^\$\n]+?)\$/g;
    let tempText = text.replace(/\$\$([\s\S]*?)\$\$/g, m => '\x00'.repeat(m.length));
    while ((match = inlineRegex.exec(tempText)) !== null) {
        formulas.push({
            type: 'formula',
            display: false,
            inner: text.slice(match.index + 1, match.index + match[0].length - 1),
            start: match.index,
            end: match.index + match[0].length
        });
    }

    // Sort by position
    formulas.sort((a, b) => a.start - b.start);

    // Build segments alternating between text and formulas
    for (const formula of formulas) {
        if (formula.start > lastEnd) {
            // Text before this formula
            segments.push({
                type: 'text',
                text: text.slice(lastEnd, formula.start),
                start: lastEnd,
                end: formula.start
            });
        }
        segments.push(formula);
        lastEnd = formula.end;
    }

    // Remaining text after last formula
    if (lastEnd < text.length) {
        segments.push({
            type: 'text',
            text: text.slice(lastEnd),
            start: lastEnd,
            end: text.length
        });
    }

    return segments;
}

// Set up the preview pane - it's read-only, editing is done in the editor pane
function attachDetailFormulaHandlers(container) {
    if (!container) return;

    // Preview pane is read-only - editing is done in the editor pane (split view)
    // Set all cursors to default
    container.querySelectorAll('.detail-formula').forEach(el => {
        el.style.cursor = 'default';
    });
    container.querySelectorAll('.detail-text').forEach(el => {
        el.style.cursor = 'default';
    });
}

// Open inline editor for a formula in detail panel
function openDetailFormulaEditor(span) {
    const segIdx = parseInt(span.dataset.segIdx);
    const isDisplay = span.dataset.display === 'true';

    const content = State.currentContent || State.contentBlocks.join('\n') || '';
    const segments = parseContentSegments(content);

    if (segIdx >= segments.length) return;
    const segment = segments[segIdx];
    if (segment.type !== 'formula') return;

    // Replace the formula span with an editor
    const originalHTML = span.innerHTML;
    span.classList.add('editing');

    const editorHTML = `
        <div class="detail-formula-editor">
            <textarea id="detailFormulaInput" rows="${isDisplay ? 4 : 2}">${escapeHtml(segment.inner)}</textarea>
        </div>
    `;
    span.innerHTML = editorHTML;

    const textarea = $('detailFormulaInput');
    textarea.focus();
    textarea.select();

    const saveFormula = () => {
        const newLatex = textarea.value;
        const delim = segment.display ? '$$' : '$';
        const newFormula = delim + newLatex + delim;

        const newContent = content.slice(0, segment.start) + newFormula + content.slice(segment.end);
        State.currentContent = newContent;
        State.contentBlocks = [newContent];
        autoSaveContent();
        span.classList.remove('editing');
        renderObsidianPreview();
    };

    textarea.addEventListener('blur', () => {
        setTimeout(() => {
            if (document.activeElement !== textarea) {
                saveFormula();
            }
        }, 100);
    });

    textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            span.classList.remove('editing');
            span.innerHTML = originalHTML;
            renderMath(span);
        } else if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
            saveFormula();
        }
    });
}

// Open inline editor for text in detail panel
function openDetailTextEditor(span) {
    const segIdx = parseInt(span.dataset.segIdx);
    const isEmptyPlaceholder = span.classList.contains('empty-placeholder');

    const content = State.currentContent || State.contentBlocks.join('\n') || '';
    const segments = parseContentSegments(content);

    let segment;
    let segmentStart = 0;
    let segmentEnd = 0;
    let segmentText = '';

    if (isEmptyPlaceholder || segments.length === 0) {
        // Empty content - create new
        segment = { type: 'text', text: '', start: 0, end: 0 };
        segmentText = '';
    } else {
        if (segIdx >= segments.length) return;
        segment = segments[segIdx];
        if (segment.type !== 'text') return;
        segmentStart = segment.start;
        segmentEnd = segment.end;
        segmentText = segment.text;
    }

    // Replace the text span with an editor
    span.classList.add('editing');

    const rows = Math.max(3, segmentText.split('\n').length);
    const editorHTML = `
        <div class="detail-text-editor">
            <textarea id="detailTextInput" rows="${rows}">${escapeHtml(segmentText)}</textarea>
        </div>
    `;
    span.innerHTML = editorHTML;

    const textarea = $('detailTextInput');
    textarea.focus();

    // Auto-resize textarea
    const autoResize = () => {
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
    };
    autoResize();
    textarea.addEventListener('input', autoResize);

    const saveText = () => {
        const newText = textarea.value;
        let newContent;
        if (isEmptyPlaceholder || segments.length === 0) {
            newContent = newText;
        } else {
            newContent = content.slice(0, segmentStart) + newText + content.slice(segmentEnd);
        }
        State.currentContent = newContent;
        State.contentBlocks = [newContent];
        autoSaveContent();
        span.classList.remove('editing');
        renderObsidianPreview();
    };

    textarea.addEventListener('blur', () => {
        setTimeout(() => {
            if (document.activeElement !== textarea) {
                saveText();
            }
        }, 100);
    });

    textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            renderObsidianPreview();
        } else if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
            saveText();
        }
    });
}

// Extract all formulas with positions from content
function extractFormulasFromContent(content) {
    const formulas = [];

    // Match display math first
    const displayRegex = /\$\$([\s\S]*?)\$\$/g;
    let match;
    while ((match = displayRegex.exec(content)) !== null) {
        formulas.push({
            full: match[0],
            inner: match[1],
            display: true,
            start: match.index,
            end: match.index + match[0].length
        });
    }

    // Then inline math (avoiding already matched display math)
    const inlineRegex = /\$([^\$\n]+?)\$/g;
    let tempContent = content.replace(/\$\$([\s\S]*?)\$\$/g, m => '\x00'.repeat(m.length));
    while ((match = inlineRegex.exec(tempContent)) !== null) {
        formulas.push({
            full: content.slice(match.index, match.index + match[0].length),
            inner: content.slice(match.index + 1, match.index + match[0].length - 1),
            display: false,
            start: match.index,
            end: match.index + match[0].length
        });
    }

    // Sort by position
    formulas.sort((a, b) => a.start - b.start);
    return formulas;
}

// ChatGPT text formatter - cleans up pasted ChatGPT output
function formatChatGPT(text) {
    if (!text) return '';

    let result = text;

    // Remove ChatGPT artifacts
    result = result.replace(/^Copy code\s*/gm, '');
    result = result.replace(/^```[\w]*\n?/gm, '');
    result = result.replace(/^```\s*$/gm, '');

    // Fix common ChatGPT math formatting issues
    // Convert \[ \] to $$
    result = result.replace(/\\\[([\s\S]*?)\\\]/g, '$$$$$1$$$$');
    // Convert \( \) to $
    result = result.replace(/\\\((.*?)\\\)/g, '$$$1$$');

    // Fix escaped underscores in math
    result = result.replace(/\\_/g, '_');

    // Clean up multiple blank lines
    result = result.replace(/\n{3,}/g, '\n\n');

    // Fix bullet points
    result = result.replace(/^[‚Ä¢‚óè‚óã]\s*/gm, '- ');

    // Format numbered lists
    result = result.replace(/^(\d+)\)\s*/gm, '$1. ');

    // Now format with editable formulas
    return formatContentWithEditableFormulas(result);
}

function splitIntoSentences(text) {
    // Keep for compatibility but not used for splitting anymore
    const blocks = [];
    let current = '';
    let inMath = 0;
    let i = 0;

    while (i < text.length) {
        const char = text[i];
        const next = text[i + 1] || '';
        const next2 = text.slice(i, i + 2);

        // Check for math delimiters
        if (inMath === 0) {
            if (next2 === '$$') {
                current += '$$';
                inMath = 2;
                i += 2;
                continue;
            } else if (char === '$') {
                const prevChar = text[i - 1] || '\n';
                if (prevChar === '\n' && (next === '\n' || next === '\r')) {
                    inMath = 3;
                } else {
                    inMath = 1;
                }
                current += char;
                i++;
                continue;
            }
        } else if (inMath === 2) {
            if (next2 === '$$') {
                current += '$$';
                inMath = 0;
                i += 2;
                continue;
            }
        } else if (inMath === 1) {
            if (char === '$' && next !== '$') {
                current += char;
                inMath = 0;
                i++;
                continue;
            }
        } else if (inMath === 3) {
            if (char === '$' && next !== '$') {
                const prevChar = text[i - 1] || '';
                if (prevChar === '\n') {
                    current += char;
                    inMath = 0;
                    i++;
                    continue;
                }
            }
        }

        current += char;

        if (inMath === 0 && (char === '.' || char === '!' || char === '?')) {
            if (next === ' ' || next === '\n') {
                let lookAhead = i + 1;
                while (lookAhead < text.length && (text[lookAhead] === ' ' || text[lookAhead] === '\n')) {
                    lookAhead++;
                }
                const afterWs = text.slice(lookAhead, lookAhead + 2);

                if (afterWs === '$$' || (text[lookAhead] === '$' && text[lookAhead + 1] !== '$')) {
                    // Don't split
                } else {
                    if (current.trim()) blocks.push(current.trim());
                    current = '';
                    i++;
                }
            }
        }
        i++;
    }

    if (current.trim()) {
        blocks.push(current.trim());
    }

    return blocks;
}

function renderAllBlocks() {
    // Now just use the Obsidian-style preview
    State.currentContent = State.contentBlocks.join('\n');
    renderObsidianPreview();
}

function editBlock(index) {
    // Open full content editor
    State.isEditingFullContent = true;
    pushToHistory();
    renderObsidianPreview();
}

function finishEditingBlock(index) {
    State.isEditingFullContent = false;
    State.editingBlockIndex = -1;
    autoSaveContent();
    renderObsidianPreview();
}

// Debounced save to prevent too many writes
let globalSaveTimer = null;
function debouncedSaveData() {
    clearTimeout(globalSaveTimer);
    globalSaveTimer = setTimeout(() => {
        saveData();
    }, 300);
}

function autoSaveContent() {
    if (!State.selectedNode) return;

    // Use currentContent or contentBlocks
    const fullContent = State.currentContent || State.contentBlocks.join('\n');

    const oldTitle = State.selectedNode.title;
    State.selectedNode.title = $('detailTitle').value.trim() || 'Untitled';
    State.selectedNode.content = fullContent;
    State.selectedNode.flashcard = $('detailFlashcard').checked;

    // Only update the specific node element instead of full canvas re-render
    const nodeEl = document.querySelector(`.node[data-id="${State.selectedNode.id}"]`);
    if (nodeEl && oldTitle !== State.selectedNode.title) {
        const titleEl = nodeEl.querySelector('.node-title');
        if (titleEl) titleEl.textContent = State.selectedNode.title;
    }

    debouncedSaveData();
}

function renderDetailView() {
    // Re-render with current format
    renderObsidianPreview();
}

function closeDetail() {
    State.isEditingFullContent = false;
    const panel = $('detailPanel');
    panel.classList.remove('open');
    panel.classList.add('view-mode');  // Reset to view mode
    State.selectedNode = null;
    State.editingBlockIndex = -1;
    State.contentBlocks = [];
    State.currentContent = '';
    renderCanvas();
}

// Debounce timer for preview updates
let previewDebounceTimer = null;
let saveDebounceTimer = null;

function enterDetailEditMode() {
    const panel = $('detailPanel');
    panel.classList.remove('view-mode');

    // Populate the editor with current content
    const editor = $('detailContentEditor');
    editor.value = State.currentContent || '';

    // Set up live preview updates with debouncing
    editor.oninput = () => {
        State.currentContent = editor.value;
        State.contentBlocks = [editor.value];

        // Debounce preview update (500ms delay for smoother typing)
        clearTimeout(previewDebounceTimer);
        previewDebounceTimer = setTimeout(() => {
            renderObsidianPreview();
        }, 500);

        // Debounce save (1000ms delay)
        clearTimeout(saveDebounceTimer);
        saveDebounceTimer = setTimeout(() => {
            autoSaveContent();
        }, 1000);
    };

    $('detailTitle').focus();
    renderObsidianPreview();
}

function exitDetailEditMode() {
    const panel = $('detailPanel');

    // Save the content from editor
    const editor = $('detailContentEditor');
    if (editor && State.selectedNode) {
        State.currentContent = editor.value;
        State.contentBlocks = [editor.value];
        autoSaveContent();
    }

    panel.classList.add('view-mode');
    State.isEditingFullContent = false;

    // Update title display from input
    if (State.selectedNode) {
        $('detailTitleDisplay').textContent = State.selectedNode.title || 'Untitled';
    }
    renderObsidianPreview();
}

// ==================== SIDEBAR.JS ====================
function renderSidebar() {
    const container = $('topicsSection');
    container.innerHTML = '';

    State.data.topics.forEach((topic, topicIndex) => {
        const group = document.createElement('div');
        group.className = 'topic-group expanded';
        group.dataset.topicId = topic.id;
        group.dataset.topicIndex = topicIndex;
        group.draggable = true;

        group.innerHTML = `
            <div class="topic-header expanded">
                <span class="arrow">&#9654;</span>
                <span class="name">${escapeHtml(topic.name)}</span>
                <div class="topic-actions">
                    <button class="add-subtopic-btn" title="Add subtopic">+</button>
                    <button class="delete-topic-btn" title="Delete topic">√ó</button>
                </div>
            </div>
            <div class="subtopics"></div>
        `;

        // Drag and drop for topics
        group.addEventListener('dragstart', (e) => {
            e.stopPropagation();
            State.draggedSidebarItem = { type: 'topic', id: topic.id, index: topicIndex };
            group.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        });

        group.addEventListener('dragend', () => {
            group.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            State.draggedSidebarItem = null;
        });

        group.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (State.draggedSidebarItem?.type === 'topic' && State.draggedSidebarItem.id !== topic.id) {
                group.classList.add('drag-over');
            }
        });

        group.addEventListener('dragleave', () => {
            group.classList.remove('drag-over');
        });

        group.addEventListener('drop', (e) => {
            e.preventDefault();
            group.classList.remove('drag-over');
            if (State.draggedSidebarItem?.type === 'topic' && State.draggedSidebarItem.id !== topic.id) {
                // Reorder topics
                const fromIndex = State.draggedSidebarItem.index;
                const toIndex = topicIndex;
                const [moved] = State.data.topics.splice(fromIndex, 1);
                State.data.topics.splice(toIndex, 0, moved);
                saveData();
                renderSidebar();
            }
        });

        // Add event listeners for topic header
        const header = group.querySelector('.topic-header');
        const topicNameSpan = header.querySelector('.name');
        const addBtn = header.querySelector('.add-subtopic-btn');

        header.addEventListener('click', (e) => {
            if (!e.target.classList.contains('name') && !e.target.classList.contains('add-subtopic-btn')) {
                toggleTopic(header);
            }
        });

        topicNameSpan.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleTopic(header);
        });

        topicNameSpan.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            startRenameTopic(topic.id, topicNameSpan);
        });

        addBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            addSubtopicTo(topic.id);
        });

        const deleteTopicBtn = header.querySelector('.delete-topic-btn');
        deleteTopicBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            deleteTopic(topic.id);
        });

        const subtopicsDiv = group.querySelector('.subtopics');

        // Allow dropping subtopics into this topic
        subtopicsDiv.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (State.draggedSidebarItem?.type === 'subtopic') {
                subtopicsDiv.classList.add('drag-over');
            }
        });

        subtopicsDiv.addEventListener('dragleave', () => {
            subtopicsDiv.classList.remove('drag-over');
        });

        subtopicsDiv.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            subtopicsDiv.classList.remove('drag-over');

            if (State.draggedSidebarItem?.type === 'subtopic') {
                const { fromTopicId, subtopicId } = State.draggedSidebarItem;

                // Move subtopic to this topic
                if (fromTopicId !== topic.id) {
                    const fromTopic = State.data.topics.find(t => t.id === fromTopicId);
                    const subIndex = fromTopic?.subtopics.findIndex(s => s.id === subtopicId);
                    if (subIndex !== undefined && subIndex >= 0) {
                        const [movedSub] = fromTopic.subtopics.splice(subIndex, 1);
                        topic.subtopics.push(movedSub);
                        saveData();
                        renderSidebar();
                    }
                }
            }
        });

        topic.subtopics.forEach((sub, subIndex) => {
            const item = document.createElement('div');
            item.className = 'subtopic-item' + (State.currentSubtopic?.id === sub.id ? ' active' : '');
            item.dataset.subtopicId = sub.id;
            item.dataset.topicId = topic.id;
            item.dataset.subIndex = subIndex;
            item.draggable = true;

            item.innerHTML = `
                <span class="subtopic-name">${escapeHtml(sub.name)}</span>
                <span class="count">${sub.nodes.length}</span>
                <button class="delete-subtopic-btn" title="Delete subtopic">√ó</button>
            `;

            // Drag and drop for subtopics
            item.addEventListener('dragstart', (e) => {
                e.stopPropagation();
                State.draggedSidebarItem = { type: 'subtopic', subtopicId: sub.id, fromTopicId: topic.id, subIndex };
                item.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });

            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                State.draggedSidebarItem = null;
            });

            item.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (State.draggedSidebarItem?.type === 'subtopic' && State.draggedSidebarItem.subtopicId !== sub.id) {
                    item.classList.add('drag-over');
                }
            });

            item.addEventListener('dragleave', () => {
                item.classList.remove('drag-over');
            });

            item.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                item.classList.remove('drag-over');

                if (State.draggedSidebarItem?.type === 'subtopic' && State.draggedSidebarItem.subtopicId !== sub.id) {
                    const { fromTopicId, subtopicId, subIndex: fromSubIndex } = State.draggedSidebarItem;
                    const fromTopic = State.data.topics.find(t => t.id === fromTopicId);
                    const toTopic = State.data.topics.find(t => t.id === topic.id);

                    if (fromTopic && toTopic) {
                        const fromIdx = fromTopic.subtopics.findIndex(s => s.id === subtopicId);
                        if (fromIdx >= 0) {
                            const [movedSub] = fromTopic.subtopics.splice(fromIdx, 1);

                            if (fromTopicId === topic.id) {
                                // Same topic - reorder
                                const toIdx = subIndex > fromIdx ? subIndex : subIndex;
                                toTopic.subtopics.splice(toIdx, 0, movedSub);
                            } else {
                                // Different topic - insert at position
                                toTopic.subtopics.splice(subIndex, 0, movedSub);
                            }

                            saveData();
                            renderSidebar();
                        }
                    }
                }
            });

            // Add double-click to rename subtopic
            const nameSpan = item.querySelector('.subtopic-name');
            nameSpan.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                startRenameSubtopic(topic.id, sub.id, nameSpan);
            });

            item.onclick = (e) => {
                if (!e.target.classList.contains('rename-input') && !e.target.classList.contains('subtopic-name') && !e.target.classList.contains('delete-subtopic-btn')) {
                    selectSubtopic(topic, sub);
                } else if (e.target.classList.contains('subtopic-name') && e.detail === 1) {
                    // Single click on name still selects
                    selectSubtopic(topic, sub);
                }
            };

            // Add delete subtopic button listener
            const deleteSubBtn = item.querySelector('.delete-subtopic-btn');
            deleteSubBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteSubtopic(topic.id, sub.id);
            });

            subtopicsDiv.appendChild(item);
        });

        container.appendChild(group);
    });
}

function startRenameTopic(topicId, nameSpan) {
    const topic = State.data.topics.find(t => t.id === topicId);
    if (!topic) return;

    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'rename-input';
    input.value = topic.name;
    input.style.cssText = 'background:var(--bg);border:1px solid var(--accent);padding:4px 8px;border-radius:4px;color:var(--text);font-size:12px;width:120px;';

    const finishRename = () => {
        const newName = input.value.trim();
        if (newName && newName !== topic.name) {
            topic.name = newName;
            saveData();
        }
        renderSidebar();
    };

    input.onblur = finishRename;
    input.onkeydown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
        } else if (e.key === 'Escape') {
            input.value = topic.name;
            input.blur();
        }
    };

    nameSpan.replaceWith(input);
    input.focus();
    input.select();
}

function startRenameSubtopic(topicId, subtopicId, nameSpan) {
    const topic = State.data.topics.find(t => t.id === topicId);
    const subtopic = topic?.subtopics.find(s => s.id === subtopicId);
    if (!subtopic) return;

    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'rename-input';
    input.value = subtopic.name;
    input.style.cssText = 'background:var(--bg);border:1px solid var(--accent);padding:4px 8px;border-radius:4px;color:var(--text);font-size:12px;width:100px;';

    const finishRename = () => {
        const newName = input.value.trim();
        if (newName && newName !== subtopic.name) {
            subtopic.name = newName;
            saveData();
        }
        renderSidebar();
    };

    input.onblur = finishRename;
    input.onkeydown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            input.blur();
        } else if (e.key === 'Escape') {
            input.value = subtopic.name;
            input.blur();
        }
    };
    input.onclick = (e) => e.stopPropagation();

    nameSpan.replaceWith(input);
    input.focus();
    input.select();
}

function toggleTopic(header) {
    header.classList.toggle('expanded');
    header.parentElement.classList.toggle('expanded');
}

function selectSubtopic(topic, subtopic) {
    State.currentSubtopic = subtopic;
    renderSidebar();
    renderCanvas();
    closeDetail();
    fitView();
}

let currentTopicForSubtopic = null;

function addSubtopicTo(topicId) {
    currentTopicForSubtopic = State.data.topics.find(t => t.id === topicId);
    $('subtopicNameInput').value = '';
    $('subtopicModal').classList.add('visible');
    $('subtopicNameInput').focus();
}

function openTopicModal() {
    $('topicNameInput').value = '';
    $('topicModal').classList.add('visible');
    $('topicNameInput').focus();
}

function closeTopicModal() {
    $('topicModal').classList.remove('visible');
}

function saveTopic() {
    const name = $('topicNameInput').value.trim();
    if (!name) {
        alert('Enter a name');
        return;
    }

    State.data.topics.push({
        id: generateId(),
        name,
        subtopics: []
    });

    saveData();
    renderSidebar();
    closeTopicModal();
}

function closeSubtopicModal() {
    $('subtopicModal').classList.remove('visible');
}

function saveSubtopic() {
    const name = $('subtopicNameInput').value.trim();
    if (!name) {
        alert('Enter a name');
        return;
    }

    const sub = {
        id: generateId(),
        name,
        nodes: []
    };

    currentTopicForSubtopic.subtopics.push(sub);
    saveData();
    renderSidebar();
    selectSubtopic(currentTopicForSubtopic, sub);
    closeSubtopicModal();
}

function deleteTopic(topicId) {
    const topic = State.data.topics.find(t => t.id === topicId);
    if (!topic) return;

    // Count total notes in topic
    const totalNotes = topic.subtopics.reduce((sum, sub) => sum + sub.nodes.length, 0);
    const subtopicCount = topic.subtopics.length;

    const message = totalNotes > 0
        ? `Delete "${topic.name}"?\n\nThis will permanently delete ${subtopicCount} subtopic(s) and ${totalNotes} note(s).`
        : `Delete "${topic.name}"?`;

    if (!confirm(message)) return;

    // Move all notes to trash
    topic.subtopics.forEach(sub => {
        sub.nodes.forEach(node => {
            State.data.trash.push({
                ...node,
                deletedAt: Date.now(),
                fromTopic: topic.id,
                fromSubtopic: sub.id
            });
        });
    });

    // Remove topic
    State.data.topics = State.data.topics.filter(t => t.id !== topicId);

    // Clear selection if current subtopic was in deleted topic
    if (State.currentSubtopic && topic.subtopics.some(s => s.id === State.currentSubtopic.id)) {
        State.currentSubtopic = null;
        State.selectedNode = null;
    }

    saveData();
    renderSidebar();
    renderCanvas();
    showToast(`Deleted topic "${topic.name}"`);
}

function deleteSubtopic(topicId, subtopicId) {
    const topic = State.data.topics.find(t => t.id === topicId);
    if (!topic) return;

    const subtopic = topic.subtopics.find(s => s.id === subtopicId);
    if (!subtopic) return;

    const noteCount = subtopic.nodes.length;
    const message = noteCount > 0
        ? `Delete "${subtopic.name}"?\n\nThis will permanently delete ${noteCount} note(s).`
        : `Delete "${subtopic.name}"?`;

    if (!confirm(message)) return;

    // Move all notes to trash
    subtopic.nodes.forEach(node => {
        State.data.trash.push({
            ...node,
            deletedAt: Date.now(),
            fromTopic: topicId,
            fromSubtopic: subtopicId
        });
    });

    // Remove subtopic
    topic.subtopics = topic.subtopics.filter(s => s.id !== subtopicId);

    // Clear selection if this was the current subtopic
    if (State.currentSubtopic?.id === subtopicId) {
        State.currentSubtopic = null;
        State.selectedNode = null;
    }

    saveData();
    renderSidebar();
    renderCanvas();
    showToast(`Deleted subtopic "${subtopic.name}"`);
}

function performSearch(query) {
    const results = $('searchResults');
    const topicsSection = $('topicsSection');

    if (!query.trim()) {
        results.classList.remove('active');
        results.innerHTML = '';
        topicsSection.style.display = 'block';
        return;
    }

    const q = query.toLowerCase();
    const matches = [];

    State.data.topics.forEach(topic => {
        topic.subtopics.forEach(sub => {
            sub.nodes.forEach(node => {
                const titleMatch = node.title?.toLowerCase().includes(q);
                const contentMatch = node.content?.toLowerCase().includes(q);

                if (titleMatch || contentMatch) {
                    let snippet = '';
                    if (contentMatch) {
                        const idx = node.content.toLowerCase().indexOf(q);
                        const start = Math.max(0, idx - 30);
                        const end = Math.min(node.content.length, idx + q.length + 30);
                        const rawSnippet = (start > 0 ? '...' : '') +
                            node.content.substring(start, end) +
                            (end < node.content.length ? '...' : '');
                        snippet = escapeHtml(rawSnippet).replace(
                            new RegExp(escapeHtml(q), 'gi'),
                            '<mark>$&</mark>'
                        );
                    }
                    matches.push({ node, topic, sub, snippet });
                }
            });
        });
    });

    topicsSection.style.display = 'none';
    results.classList.add('active');

    if (matches.length === 0) {
        results.innerHTML = '<div style="padding:15px;color:var(--text2);font-size:13px;">No results found</div>';
        return;
    }

    results.innerHTML = matches.slice(0, 20).map(m => `
        <div class="search-result" onclick="goToSearchResult('${m.topic.id}', '${m.sub.id}', '${m.node.id}')">
            <div class="title">${escapeHtml(m.node.title)}</div>
            <div class="path">${escapeHtml(m.topic.name)} ‚Üí ${escapeHtml(m.sub.name)}</div>
            ${m.snippet ? `<div class="snippet">${m.snippet}</div>` : ''}
        </div>
    `).join('');
}

function goToSearchResult(topicId, subId, nodeId) {
    const topic = State.data.topics.find(t => t.id === topicId);
    const sub = topic?.subtopics.find(s => s.id === subId);

    if (sub) {
        $('searchInput').value = '';
        $('searchResults').classList.remove('active');
        $('topicsSection').style.display = 'block';

        switchView('notes');
        selectSubtopic(topic, sub);

        setTimeout(() => {
            const node = sub.nodes.find(n => n.id === nodeId);
            if (node) selectNode(node);
        }, 100);
    }
}

function toggleSidebar() {
    const sidebar = $('sidebar');
    const toggle = $('sidebarToggle');
    const isCollapsed = sidebar.classList.toggle('collapsed');
    toggle.classList.toggle('collapsed', isCollapsed);
    toggle.textContent = isCollapsed ? '‚ñ∂' : '‚óÄ';
}

// ==================== SYNC.JS ====================
const SYNC_API = 'https://jsonblob.com/api/jsonBlob';

function openSyncModal() {
    $('syncPassword').value = '';
    $('syncId').value = State.syncId;
    $('currentSyncId').textContent = State.syncId || 'Not set';
    $('syncResult').style.display = 'none';

    // Show last auto-save time
    const lastSave = localStorage.getItem('mindnotes_lastSave');
    if (lastSave) {
        const date = new Date(lastSave);
        $('lastAutoSave').textContent = date.toLocaleString();
    } else {
        $('lastAutoSave').textContent = 'Never';
    }

    $('syncModal').classList.add('visible');
}

function closeSyncModal() {
    $('syncModal').classList.remove('visible');
}

// ==================== LOCAL BACKUP ====================

function downloadLocalBackup() {
    const backup = {
        version: '2.0',
        exportedAt: new Date().toISOString(),
        data: State.data,
        syncId: State.syncId,
        theme: localStorage.getItem('mindnotes_theme') || 'dark'
    };

    const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `mindnotes-backup-${new Date().toISOString().slice(0,10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    showToast('Backup downloaded successfully!');
}

function restoreFromBackup(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const backup = JSON.parse(e.target.result);

            // Validate backup structure
            if (!backup.data || !backup.data.topics) {
                throw new Error('Invalid backup file structure');
            }

            // Confirm restore
            if (!confirm(`Restore backup from ${backup.exportedAt || 'unknown date'}?\n\nThis will replace all your current notes. This action cannot be undone.`)) {
                return;
            }

            // Restore data
            State.data = backup.data;
            if (backup.syncId) {
                State.syncId = backup.syncId;
                localStorage.setItem('mindnotes_syncId', backup.syncId);
            }
            if (backup.theme) {
                localStorage.setItem('mindnotes_theme', backup.theme);
                loadTheme();
            }

            saveData();
            renderSidebar();
            updateFlashcardStats();

            // Select first subtopic if available
            if (State.data.topics.length && State.data.topics[0].subtopics.length) {
                selectSubtopic(State.data.topics[0], State.data.topics[0].subtopics[0]);
            } else {
                State.currentSubtopic = null;
                renderCanvas();
            }

            showToast('Backup restored successfully!');
            closeSyncModal();
        } catch (err) {
            showToast('Failed to restore: ' + err.message);
        }
    };
    reader.readAsText(file);

    // Reset file input
    event.target.value = '';
}

function updateLastAutoSaveTime() {
    const el = $('lastAutoSave');
    if (el) {
        el.textContent = new Date().toLocaleTimeString();
    }
}

// ==================== TRASH FUNCTIONS ====================

function updateTrashCount() {
    const count = State.data.trash?.length || 0;
    const el = $('trashCount');
    if (el) el.textContent = count;
}

function openTrashModal() {
    renderTrashList();
    $('trashModal').classList.add('visible');
}

function closeTrashModal() {
    $('trashModal').classList.remove('visible');
}

function renderTrashList() {
    const list = $('trashList');
    const empty = $('trashEmpty');
    const trash = State.data.trash || [];

    if (trash.length === 0) {
        list.style.display = 'none';
        empty.style.display = 'block';
        return;
    }

    list.style.display = 'flex';
    empty.style.display = 'none';
    list.innerHTML = '';

    // Sort by deletion date (newest first)
    const sorted = [...trash].sort((a, b) => b.deletedAt - a.deletedAt);

    sorted.forEach(item => {
        const div = document.createElement('div');
        div.style.cssText = 'display:flex; align-items:center; gap:12px; padding:12px; background:var(--bg3); border-radius:8px;';

        const deletedDate = new Date(item.deletedAt).toLocaleDateString();
        const daysLeft = Math.max(0, 30 - Math.floor((Date.now() - item.deletedAt) / (24*60*60*1000)));

        div.innerHTML = `
            <div style="flex:1;">
                <div style="font-weight:600; color:var(--text);">${escapeHtml(item.title || 'Untitled')}</div>
                <div style="font-size:11px; color:var(--text2); margin-top:4px;">
                    Deleted ${deletedDate} ‚Ä¢ ${daysLeft} days left
                </div>
            </div>
            <button class="btn btn-ghost" style="padding:6px 12px; font-size:12px;" onclick="restoreFromTrash('${item.id}')">Restore</button>
            <button class="btn btn-ghost" style="padding:6px 12px; font-size:12px; color:var(--red);" onclick="permanentlyDelete('${item.id}')">Delete</button>
        `;
        list.appendChild(div);
    });
}

function restoreFromTrash(nodeId) {
    const index = State.data.trash.findIndex(n => n.id === nodeId);
    if (index === -1) return;

    const item = State.data.trash[index];

    // Find target subtopic
    let targetSub = null;
    for (const topic of State.data.topics) {
        const sub = topic.subtopics.find(s => s.id === item.fromSubtopic);
        if (sub) {
            targetSub = sub;
            break;
        }
    }

    // If original subtopic doesn't exist, use first available
    if (!targetSub && State.data.topics.length && State.data.topics[0].subtopics.length) {
        targetSub = State.data.topics[0].subtopics[0];
    }

    if (!targetSub) {
        showToast('No subtopic available to restore to');
        return;
    }

    // Remove from trash and add to subtopic
    State.data.trash.splice(index, 1);
    const { deletedAt, fromTopic, fromSubtopic, ...cleanNode } = item;
    targetSub.nodes.push(cleanNode);

    saveData();
    renderTrashList();
    updateTrashCount();
    renderSidebar();
    if (State.currentSubtopic?.id === targetSub.id) {
        renderCanvas();
    }
    showToast('Note restored');
}

function permanentlyDelete(nodeId) {
    if (!confirm('Permanently delete this note? This cannot be undone.')) return;

    const index = State.data.trash.findIndex(n => n.id === nodeId);
    if (index !== -1) {
        State.data.trash.splice(index, 1);
        saveData();
        renderTrashList();
        updateTrashCount();
    }
}

function emptyTrash() {
    if (!State.data.trash?.length) return;
    if (!confirm(`Permanently delete all ${State.data.trash.length} notes in trash?`)) return;

    State.data.trash = [];
    saveData();
    renderTrashList();
    updateTrashCount();
    showToast('Trash emptied');
}

// ==================== COPY/PASTE NOTES ====================

function copySelectedNotes() {
    const nodesToCopy = [];

    if (State.selectedNodes.length > 0) {
        // Copy multi-selected nodes
        State.selectedNodes.forEach(id => {
            const node = State.currentSubtopic?.nodes.find(n => n.id === id);
            if (node) nodesToCopy.push({ ...node });
        });
    } else if (State.selectedNode) {
        // Copy single selected node
        nodesToCopy.push({ ...State.selectedNode });
    }

    if (nodesToCopy.length === 0) {
        showToast('No notes selected to copy');
        return;
    }

    State.clipboard = {
        nodes: nodesToCopy,
        sourceSubtopic: State.currentSubtopic?.id
    };

    // Visual feedback
    renderCanvas();
    showToast(`Copied ${nodesToCopy.length} note${nodesToCopy.length > 1 ? 's' : ''} (Cmd+V to paste)`);
}

function pasteNotes() {
    if (!State.clipboard || !State.clipboard.nodes.length) {
        showToast('Nothing to paste');
        return;
    }

    if (!State.currentSubtopic) {
        showToast('Select a subtopic first');
        return;
    }

    // Calculate offset for pasted notes
    const offset = State.clipboard.sourceSubtopic === State.currentSubtopic.id ? 50 : 0;

    const newNodes = State.clipboard.nodes.map(node => {
        const { id, links, ...rest } = node;
        return {
            ...rest,
            id: generateId(),
            x: node.x + offset,
            y: node.y + offset,
            links: []  // Don't copy links
        };
    });

    State.currentSubtopic.nodes.push(...newNodes);
    saveData();
    renderCanvas();
    renderSidebar();

    // Select the pasted nodes
    State.selectedNodes = newNodes.map(n => n.id);
    State.selectedNode = null;
    renderCanvas();
    updateSelectionToolbar();

    showToast(`Pasted ${newNodes.length} note${newNodes.length > 1 ? 's' : ''}`);
}

// ==================== MULTI-SELECTION ====================

function deleteSelectedNodes() {
    if (State.selectedNodes.length === 0) return;

    State.selectedNodes.forEach(id => {
        const node = State.currentSubtopic?.nodes.find(n => n.id === id);
        if (node) {
            const location = findNodeLocation(id);
            State.data.trash.push({
                ...node,
                deletedAt: Date.now(),
                fromTopic: location?.topic.id,
                fromSubtopic: location?.subtopic.id
            });

            // Remove links to this node
            State.currentSubtopic.nodes.forEach(n => {
                n.links = n.links?.filter(linkId => linkId !== id) || [];
            });
        }
    });

    State.currentSubtopic.nodes = State.currentSubtopic.nodes.filter(
        n => !State.selectedNodes.includes(n.id)
    );

    saveData();
    State.selectedNodes = [];
    State.selectedNode = null;
    closeDetail();
    renderCanvas();
    renderSidebar();
    updateTrashCount();
    updateSelectionToolbar();
    showToast('Notes moved to trash');
}

function startRectangleSelection(e) {
    if (e.target !== canvas && e.target.id !== 'canvasBg') return;
    if (e.button !== 0) return;  // Left click only
    if (e.metaKey || e.ctrlKey) return;  // Not when linking

    const rect = canvasWrapper.getBoundingClientRect();
    const x = (e.clientX - rect.left - State.pan.x) / State.zoom + 5000;
    const y = (e.clientY - rect.top - State.pan.y) / State.zoom + 5000;

    State.isSelecting = true;
    State.selectionStart = { x, y };

    // Create selection rectangle element
    State.selectionRect = document.createElement('div');
    State.selectionRect.className = 'selection-rect';
    canvas.appendChild(State.selectionRect);
}

function updateRectangleSelection(e) {
    if (!State.isSelecting || !State.selectionRect) return;

    const rect = canvasWrapper.getBoundingClientRect();
    const x = (e.clientX - rect.left - State.pan.x) / State.zoom + 5000;
    const y = (e.clientY - rect.top - State.pan.y) / State.zoom + 5000;

    const left = Math.min(State.selectionStart.x, x);
    const top = Math.min(State.selectionStart.y, y);
    const width = Math.abs(x - State.selectionStart.x);
    const height = Math.abs(y - State.selectionStart.y);

    State.selectionRect.style.left = left + 'px';
    State.selectionRect.style.top = top + 'px';
    State.selectionRect.style.width = width + 'px';
    State.selectionRect.style.height = height + 'px';

    // Highlight nodes within selection
    const selectedIds = [];
    State.currentSubtopic?.nodes.forEach(node => {
        const nodeLeft = node.x;
        const nodeTop = node.y;
        const nodeRight = node.x + (node.width || 200);
        const nodeBottom = node.y + (node.height || 150);

        // Check if node overlaps with selection rectangle
        if (nodeRight > left && nodeLeft < left + width &&
            nodeBottom > top && nodeTop < top + height) {
            selectedIds.push(node.id);
        }
    });

    // Update visual selection
    document.querySelectorAll('.node').forEach(el => {
        if (selectedIds.includes(el.dataset.id)) {
            el.classList.add('multi-selected');
        } else {
            el.classList.remove('multi-selected');
        }
    });

    State.selectedNodes = selectedIds;
}

function endRectangleSelection(e) {
    if (!State.isSelecting) return;

    State.isSelecting = false;
    if (State.selectionRect) {
        State.selectionRect.remove();
        State.selectionRect = null;
    }

    if (State.selectedNodes.length > 0) {
        State.selectedNode = null;  // Clear single selection
        showToast(`Selected ${State.selectedNodes.length} notes`);
    }

    updateSelectionToolbar();
}

// ==================== SELECTION TOOLBAR ====================

function updateSelectionToolbar() {
    const toolbar = $('selectionToolbar');
    const countEl = $('selectionCount');

    if (State.selectedNodes.length > 0) {
        toolbar.classList.add('visible');
        countEl.textContent = `${State.selectedNodes.length} selected`;
    } else {
        toolbar.classList.remove('visible');
        hideMoveMenu();
    }
}

function clearSelection() {
    State.selectedNodes = [];
    State.selectedNode = null;
    document.querySelectorAll('.node.multi-selected').forEach(el => {
        el.classList.remove('multi-selected');
    });
    updateSelectionToolbar();
    hideMoveMenu();
}

function selectAllNodes() {
    if (!State.currentSubtopic || State.currentSubtopic.nodes.length === 0) {
        showToast('No notes to select');
        return;
    }

    State.selectedNodes = State.currentSubtopic.nodes.map(n => n.id);
    State.selectedNode = null;

    // Update visual selection
    document.querySelectorAll('.node').forEach(el => {
        el.classList.add('multi-selected');
    });

    updateSelectionToolbar();
    showToast(`Selected all ${State.selectedNodes.length} notes (Cmd+A)`);
}

function showMoveMenu() {
    const menu = $('moveMenu');

    if (menu.classList.contains('visible')) {
        hideMoveMenu();
        return;
    }

    // Build menu with all subtopics
    let html = '';
    State.data.topics.forEach(topic => {
        html += `<div class="move-menu-item topic-header">${escapeHtml(topic.name)}</div>`;
        topic.subtopics.forEach(sub => {
            const isCurrent = State.currentSubtopic?.id === sub.id;
            html += `<div class="move-menu-item${isCurrent ? ' current' : ''}"
                          onclick="moveSelectedNodesToSubtopic('${topic.id}', '${sub.id}')"
                          ${isCurrent ? 'title="Current subtopic"' : ''}>
                        ${isCurrent ? '‚Ä¢ ' : ''}${escapeHtml(sub.name)}
                     </div>`;
        });
    });

    menu.innerHTML = html;
    menu.classList.add('visible');
}

function hideMoveMenu() {
    const menu = $('moveMenu');
    menu.classList.remove('visible');
}

function moveSelectedNodesToSubtopic(topicId, subtopicId) {
    if (State.selectedNodes.length === 0) return;

    // Can't move to current subtopic
    if (State.currentSubtopic?.id === subtopicId) {
        showToast('Notes are already in this subtopic');
        hideMoveMenu();
        return;
    }

    // Find target subtopic
    let targetSubtopic = null;
    for (const topic of State.data.topics) {
        if (topic.id === topicId) {
            targetSubtopic = topic.subtopics.find(s => s.id === subtopicId);
            break;
        }
    }

    if (!targetSubtopic) {
        showToast('Target subtopic not found');
        return;
    }

    // Move nodes
    const nodesToMove = [];
    State.selectedNodes.forEach(id => {
        const idx = State.currentSubtopic.nodes.findIndex(n => n.id === id);
        if (idx !== -1) {
            const node = State.currentSubtopic.nodes.splice(idx, 1)[0];
            // Remove links to other nodes that aren't being moved
            node.links = node.links?.filter(linkId => State.selectedNodes.includes(linkId)) || [];
            nodesToMove.push(node);
        }
    });

    // Also update links in remaining nodes
    State.currentSubtopic.nodes.forEach(node => {
        node.links = node.links?.filter(linkId => !State.selectedNodes.includes(linkId)) || [];
    });

    // Add to target
    targetSubtopic.nodes.push(...nodesToMove);

    saveData();
    clearSelection();
    renderCanvas();
    renderSidebar();
    hideMoveMenu();
    showToast(`Moved ${nodesToMove.length} note${nodesToMove.length > 1 ? 's' : ''} to ${targetSubtopic.name}`);
}

// Close move menu when clicking outside
document.addEventListener('click', (e) => {
    if (!e.target.closest('#moveMenu') && !e.target.closest('#moveMenuBtn')) {
        hideMoveMenu();
    }
});

function encrypt(data, password) {
    const str = JSON.stringify(data);
    let hash = 0;
    for (let i = 0; i < password.length; i++) {
        hash = ((hash << 5) - hash) + password.charCodeAt(i);
        hash = hash & hash;
    }
    const key = Math.abs(hash).toString();
    let result = '';
    for (let i = 0; i < str.length; i++) {
        result += String.fromCharCode(str.charCodeAt(i) ^ key.charCodeAt(i % key.length));
    }
    return btoa(encodeURIComponent(result));
}

function decrypt(encoded, password) {
    try {
        const str = decodeURIComponent(atob(encoded));
        let hash = 0;
        for (let i = 0; i < password.length; i++) {
            hash = ((hash << 5) - hash) + password.charCodeAt(i);
            hash = hash & hash;
        }
        const key = Math.abs(hash).toString();
        let result = '';
        for (let i = 0; i < str.length; i++) {
            result += String.fromCharCode(str.charCodeAt(i) ^ key.charCodeAt(i % key.length));
        }
        return JSON.parse(result);
    } catch (e) {
        return null;
    }
}

async function uploadToCloud() {
    const password = $('syncPassword').value;
    const existingId = $('syncId').value.trim();

    if (!password) {
        showSyncResult('Please enter a password', false);
        return;
    }

    const encrypted = encrypt(State.data, password);
    const payload = { data: encrypted, timestamp: Date.now() };

    try {
        $('syncBtn').classList.add('syncing');

        let response;
        if (existingId) {
            response = await fetch(`${SYNC_API}/${existingId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            State.syncId = existingId;
        } else {
            response = await fetch(SYNC_API, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            State.syncId = response.headers.get('X-jsonblob') || response.url.split('/').pop();
        }

        if (response.ok) {
            localStorage.setItem('mindnotes_syncId', State.syncId);
            $('syncId').value = State.syncId;
            $('currentSyncId').textContent = State.syncId;
            $('syncBtn').classList.add('synced');
            $('syncStatus').classList.add('active');
            $('syncStatusText').textContent = 'Synced: ' + new Date().toLocaleTimeString();
            showSyncResult(`Uploaded! ID: ${State.syncId}`, true);
        } else {
            throw new Error('Upload failed');
        }
    } catch (e) {
        showSyncResult('Upload failed. Try again.', false);
    } finally {
        $('syncBtn').classList.remove('syncing');
    }
}

async function downloadFromCloud() {
    const password = $('syncPassword').value;
    const id = $('syncId').value.trim();

    if (!password || !id) {
        showSyncResult('Please enter both Sync ID and password', false);
        return;
    }

    try {
        $('syncBtn').classList.add('syncing');

        const response = await fetch(`${SYNC_API}/${id}`);
        if (!response.ok) throw new Error('Not found');

        const payload = await response.json();
        const decrypted = decrypt(payload.data, password);

        if (!decrypted || !decrypted.topics) {
            showSyncResult('Wrong password or corrupted data', false);
            return;
        }

        State.data = decrypted;
        saveData();
        State.syncId = id;
        localStorage.setItem('mindnotes_syncId', State.syncId);

        renderSidebar();
        updateFlashcardStats();

        if (State.data.topics.length && State.data.topics[0].subtopics.length) {
            selectSubtopic(State.data.topics[0], State.data.topics[0].subtopics[0]);
        }

        $('currentSyncId').textContent = State.syncId;
        $('syncBtn').classList.add('synced');
        $('syncStatus').classList.add('active');
        $('syncStatusText').textContent = 'Restored: ' + new Date().toLocaleTimeString();
        showSyncResult(`Notes restored! Found ${State.data.topics.length} topics.`, true);
    } catch (e) {
        showSyncResult('Could not find or decrypt data.', false);
    } finally {
        $('syncBtn').classList.remove('syncing');
    }
}

function showSyncResult(message, success) {
    const resultDiv = $('syncResult');
    resultDiv.innerHTML = (success ? '‚úÖ ' : '‚ùå ') + message;
    resultDiv.style.color = success ? 'var(--green)' : 'var(--red)';
    resultDiv.style.display = 'block';
}

// ==================== VIEWS.JS ====================
function switchView(view) {
    State.currentView = view;

    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
    $('tab' + view.charAt(0).toUpperCase() + view.slice(1)).classList.add('active');

    $('canvasWrapper').style.display = view === 'notes' ? 'flex' : 'none';
    $('detailPanel').style.display = view === 'notes' ? 'flex' : 'none';
    $('flashcardsView').classList.toggle('active', view === 'flashcards');
    $('quizView').classList.toggle('active', view === 'quiz');

    $('topicsSection').style.display = view === 'notes' ? 'block' : 'none';
    document.querySelector('.add-btn').style.display = view === 'notes' ? 'block' : 'none';

    if (view === 'flashcards') updateFlashcardStats();
    if (view === 'quiz') updateQuizView();
}

function updateFlashcardStats() {
    // Count cards by state
    let totalCards = 0;
    let dueCards = 0;
    let newCards = 0;
    let learningCards = 0;
    let reviewCards = 0;
    let relearningCards = 0;

    State.data.topics.forEach(topic => {
        topic.subtopics.forEach(sub => {
            sub.nodes.forEach(node => {
                if (node.flashcard) {
                    FSRS.initCard(node);
                    totalCards++;

                    const state = node.fsrs.state;
                    if (state === 'new') newCards++;
                    else if (state === 'learning') learningCards++;
                    else if (state === 'review') reviewCards++;
                    else if (state === 'relearning') relearningCards++;

                    if (FSRS.isDue(node)) dueCards++;
                }
            });
        });
    });

    // Update stats display
    $('fcTotalCards').textContent = totalCards;
    $('fcDueCards').textContent = dueCards;
    $('fcNewCards').textContent = newCards;
    $('fcLearningCards').textContent = learningCards + relearningCards;

    // Update mode buttons
    $('startFcBtn').disabled = dueCards === 0;
    $('fcOptimalDesc').textContent = dueCards + ' cards due';

    $('startAllBtn').disabled = totalCards === 0;
    $('fcAllDesc').textContent = totalCards + ' cards total';

    // Update badge
    const badge = $('fcBadge');
    if (dueCards > 0) {
        badge.textContent = dueCards;
        badge.style.display = 'inline';
    } else {
        badge.style.display = 'none';
    }

    // Update distribution bar
    if (totalCards > 0) {
        $('distNew').style.width = (newCards / totalCards * 100) + '%';
        $('distLearning').style.width = (learningCards / totalCards * 100) + '%';
        $('distReview').style.width = (reviewCards / totalCards * 100) + '%';
        $('distRelearning').style.width = (relearningCards / totalCards * 100) + '%';
    }

    // Render retention chart
    renderRetentionChart();
}

function renderRetentionChart() {
    const canvas = $('retentionChart');
    const placeholder = $('chartPlaceholder');
    const reviews = State.reviewHistory;

    if (reviews.length < 2) {
        canvas.style.display = 'none';
        placeholder.style.display = 'block';
        return;
    }

    canvas.style.display = 'block';
    placeholder.style.display = 'none';

    // Group reviews by day and calculate retention
    const dailyStats = {};
    reviews.forEach(r => {
        const day = r.timestamp.split('T')[0];
        if (!dailyStats[day]) {
            dailyStats[day] = { total: 0, correct: 0 };
        }
        dailyStats[day].total++;
        if (r.rating >= 3) dailyStats[day].correct++;
    });

    const days = Object.keys(dailyStats).sort().slice(-14); // Last 14 days
    const retentions = days.map(d => Math.round(dailyStats[d].correct / dailyStats[d].total * 100));

    // Draw chart
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    const padding = 30;

    ctx.clearRect(0, 0, w, h);

    if (days.length < 2) return;

    // Draw grid
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border').trim();
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
        const y = padding + (h - 2 * padding) * i / 4;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(w - padding, y);
        ctx.stroke();
    }

    // Draw line
    const xStep = (w - 2 * padding) / (days.length - 1);
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--green').trim();
    ctx.lineWidth = 2;
    ctx.beginPath();

    retentions.forEach((r, i) => {
        const x = padding + i * xStep;
        const y = h - padding - (r / 100) * (h - 2 * padding);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Draw points
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--green').trim();
    retentions.forEach((r, i) => {
        const x = padding + i * xStep;
        const y = h - padding - (r / 100) * (h - 2 * padding);
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
    });

    // Labels
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text2').trim();
    ctx.font = '10px -apple-system, sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('100%', padding - 5, padding + 3);
    ctx.fillText('50%', padding - 5, h / 2 + 3);
    ctx.fillText('0%', padding - 5, h - padding + 3);
}

function getAllFlashcards(data) {
    const allCards = [];
    data.topics.forEach(topic => {
        topic.subtopics.forEach(sub => {
            sub.nodes.forEach(node => {
                if (node.flashcard) {
                    FSRS.initCard(node);
                    allCards.push({
                        node,
                        topic: topic.name,
                        subtopic: sub.name,
                        topicId: topic.id,
                        subtopicId: sub.id
                    });
                }
            });
        });
    });

    // Shuffle for variety
    for (let i = allCards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allCards[i], allCards[j]] = [allCards[j], allCards[i]];
    }

    return allCards;
}

function startFlashcards(mode = 'optimal') {
    let cards;

    if (mode === 'all') {
        // Get ALL flashcard-marked cards
        cards = getAllFlashcards(State.data);
    } else {
        // Get only due cards (optimal spacing)
        cards = FSRS.getDueCards(State.data);
    }

    if (cards.length === 0) {
        showToast(mode === 'all' ? 'No flashcards found!' : 'No cards due for review!');
        return;
    }

    // Initialize session
    State.flashcardSession = {
        active: true,
        mode: mode,
        cards: cards,
        currentIndex: 0,
        showAnswer: false,
        sessionStart: new Date(),
        cardsReviewed: 0,
        correctAnswers: 0,
        reviewHistory: [],
        ratings: { 1: 0, 2: 0, 3: 0, 4: 0 }
    };

    // Show review screen
    $('fcStartScreen').style.display = 'none';
    $('fcReviewScreen').style.display = 'flex';
    $('fcCompleteScreen').style.display = 'none';

    showCurrentFlashcard();
}

function showCurrentFlashcard() {
    const session = State.flashcardSession;
    if (session.currentIndex >= session.cards.length) {
        showSessionComplete();
        return;
    }

    const cardData = session.cards[session.currentIndex];
    const node = cardData.node;
    FSRS.initCard(node);

    // Update progress
    $('fcProgress').textContent = `${session.currentIndex + 1}/${session.cards.length}`;
    $('fcProgressFill').style.width = ((session.currentIndex + 1) / session.cards.length * 100) + '%';

    // Update card display
    $('fcCardTopic').textContent = `${cardData.topic} > ${cardData.subtopic}`;
    $('fcCardTitle').textContent = node.title || 'Untitled';

    const content = node.content || '';
    const format = localStorage.getItem('mindnotes_format') || 'latex';

    // Front: Show title as prompt, with hint to recall content
    $('fcCardContent').innerHTML = '<p style="color:var(--text2);font-style:italic;">Try to recall what you know about this topic...</p>';

    // Back: Show full content as answer
    let formattedContent;
    if (format === 'obsidian') {
        formattedContent = formatForObsidian(content);
    } else {
        formattedContent = formatContent(escapeHtml(content));
    }
    $('fcCardAnswer').innerHTML = formattedContent;

    // Render math
    renderMath($('fcCardContent'));
    renderMath($('fcCardAnswer'));

    // Update card info
    $('fcCardState').textContent = node.fsrs.state.charAt(0).toUpperCase() + node.fsrs.state.slice(1);
    $('fcCardReps').textContent = node.fsrs.reps + ' reps';
    $('fcCardStability').textContent = 'Stability: ' + node.fsrs.stability.toFixed(1);

    // Get next intervals
    const intervals = FSRS.getNextIntervals(node);
    $('fcInterval1').textContent = FSRS.formatInterval(intervals[1]);
    $('fcInterval2').textContent = FSRS.formatInterval(intervals[2]);
    $('fcInterval3').textContent = FSRS.formatInterval(intervals[3]);
    $('fcInterval4').textContent = FSRS.formatInterval(intervals[4]);

    // Reset view state
    session.showAnswer = false;
    $('fcCardBack').style.display = 'none';
    $('fcShowAnswerSection').style.display = 'block';
    $('fcRatingSection').style.display = 'none';
}

function showFlashcardAnswer() {
    State.flashcardSession.showAnswer = true;
    $('fcCardBack').style.display = 'block';
    $('fcShowAnswerSection').style.display = 'none';
    $('fcRatingSection').style.display = 'block';
}

function rateFlashcard(rating) {
    const session = State.flashcardSession;
    const cardData = session.cards[session.currentIndex];
    const node = cardData.node;

    // Record the review
    const reviewLog = FSRS.reviewCard(node, rating);

    // Update session stats
    session.cardsReviewed++;
    session.ratings[rating]++;
    if (rating >= 3) session.correctAnswers++;
    session.reviewHistory.push(reviewLog);

    // Save to persistent history
    State.reviewHistory.push(reviewLog);
    if (State.reviewHistory.length > 1000) {
        State.reviewHistory = State.reviewHistory.slice(-1000); // Keep last 1000
    }
    localStorage.setItem('mindnotes_reviews', JSON.stringify(State.reviewHistory));

    // Save data
    saveData();

    // Move to next card
    session.currentIndex++;
    showCurrentFlashcard();
}

function endFlashcardSession() {
    if (State.flashcardSession.cardsReviewed > 0) {
        showSessionComplete();
    } else {
        showFlashcardStart();
    }
}

function showSessionComplete() {
    const session = State.flashcardSession;

    $('fcStartScreen').style.display = 'none';
    $('fcReviewScreen').style.display = 'none';
    $('fcCompleteScreen').style.display = 'flex';

    // Calculate stats
    const reviewed = session.cardsReviewed;
    const retention = reviewed > 0 ? Math.round(session.correctAnswers / reviewed * 100) : 0;
    const duration = Math.round((new Date() - session.sessionStart) / 60000);

    $('fcSessionReviewed').textContent = reviewed;
    $('fcSessionCorrect').textContent = retention + '%';
    $('fcSessionTime').textContent = duration + 'm';

    // Rating breakdown
    const breakdown = $('fcRatingBreakdown');
    breakdown.innerHTML = `
        <div class="rating-item again">
            <div class="rating-count">${session.ratings[1]}</div>
            <div class="rating-name">Again</div>
        </div>
        <div class="rating-item hard">
            <div class="rating-count">${session.ratings[2]}</div>
            <div class="rating-name">Hard</div>
        </div>
        <div class="rating-item good">
            <div class="rating-count">${session.ratings[3]}</div>
            <div class="rating-name">Good</div>
        </div>
        <div class="rating-item easy">
            <div class="rating-count">${session.ratings[4]}</div>
            <div class="rating-name">Easy</div>
        </div>
    `;

    // Reset session
    State.flashcardSession.active = false;
}

function showFlashcardStart() {
    $('fcStartScreen').style.display = 'flex';
    $('fcReviewScreen').style.display = 'none';
    $('fcCompleteScreen').style.display = 'none';
    updateFlashcardStats();
}

function updateQuizView() {
    let totalNotes = 0;
    State.data.topics.forEach(topic => {
        topic.subtopics.forEach(sub => {
            totalNotes += sub.nodes.length;
        });
    });
    $('quizTotalNotes').textContent = totalNotes;

    const container = $('quizTopics');
    container.innerHTML = '';

    State.data.topics.forEach(topic => {
        topic.subtopics.forEach(sub => {
            if (sub.nodes.length === 0) return;

            const btn = document.createElement('button');
            btn.className = 'quiz-topic-btn' + (State.selectedQuizTopics.has(sub.id) ? ' selected' : '');
            btn.textContent = `${topic.name} ‚Üí ${sub.name} (${sub.nodes.length})`;
            btn.onclick = () => {
                if (State.selectedQuizTopics.has(sub.id)) {
                    State.selectedQuizTopics.delete(sub.id);
                } else {
                    State.selectedQuizTopics.add(sub.id);
                }
                updateQuizView();
            };
            container.appendChild(btn);
        });
    });
}

function exportForQuiz() {
    let exportText = '# MY STUDY NOTES\n\n';
    exportText += 'Please create a quiz based on these notes.\n\n---\n\n';

    const topicsToExport = State.selectedQuizTopics.size > 0 ? State.selectedQuizTopics : null;

    State.data.topics.forEach(topic => {
        topic.subtopics.forEach(sub => {
            if (topicsToExport && !topicsToExport.has(sub.id)) return;
            if (sub.nodes.length === 0) return;

            exportText += `## ${topic.name} - ${sub.name}\n\n`;
            sub.nodes.forEach(node => {
                exportText += `### ${node.title}\n`;
                exportText += node.content + '\n\n';
            });
        });
    });

    $('exportText').value = exportText;
    $('exportBox').style.display = 'block';
}

async function copyExport() {
    const text = $('exportText').value;
    const success = await copyToClipboard(text);
    showToast(success ? 'Notes copied to clipboard!' : 'Failed to copy');
}

function toggleTheme() {
    const html = document.documentElement;
    const currentTheme = html.getAttribute('data-theme');
    const newTheme = currentTheme === 'light' ? null : 'light';

    if (newTheme) {
        html.setAttribute('data-theme', newTheme);
    } else {
        html.removeAttribute('data-theme');
    }

    localStorage.setItem('mindnotes_theme', newTheme || 'dark');
    $('themeToggle').textContent = newTheme === 'light' ? '‚òÄÔ∏è' : 'üåô';
}

function loadTheme() {
    const savedTheme = localStorage.getItem('mindnotes_theme') || 'dark';

    if (savedTheme === 'light') {
        document.documentElement.setAttribute('data-theme', 'light');
    } else {
        document.documentElement.removeAttribute('data-theme');
    }

    $('themeToggle').textContent = savedTheme === 'light' ? '‚òÄÔ∏è' : 'üåô';
}

// ==================== APP.JS ====================
async function initApp() {
    initCanvasRefs();
    initCanvasEvents();
    initKeyboardEvents();
    initImageInput();
    initDetailImageInput();

    loadTheme();
    await loadData(); // loadData handles rendering after load

    updateFlashcardStats();
    updateTrashCount();

    // Auto-save when title changes in detail panel
    const detailTitle = $('detailTitle');
    if (detailTitle) {
        detailTitle.addEventListener('input', () => {
            if (State.selectedNode) {
                autoSaveContent();
            }
        });
    }

    console.log('MindNotes initialized successfully');
}

function initCanvasEvents() {
    let wasPanning = false;
    let panMoved = false;

    document.addEventListener('mousemove', (e) => {
        // Handle rectangle selection
        if (State.isSelecting) {
            updateRectangleSelection(e);
            return;
        }

        handleDragMove(e);
        handlePanMove(e);

        if (wasPanning && State.isPanning) {
            panMoved = true;
        }

        if (State.isLinking && State.linkLine) {
            const rect = canvasWrapper.getBoundingClientRect();
            const x = (e.clientX - rect.left - State.pan.x) / State.zoom + 5000;
            const y = (e.clientY - rect.top - State.pan.y) / State.zoom + 5000;
            State.linkLine.setAttribute('x2', x);
            State.linkLine.setAttribute('y2', y);
        }
    });

    document.addEventListener('mouseup', (e) => {
        // Handle rectangle selection end
        if (State.isSelecting) {
            endRectangleSelection(e);
            return;
        }

        // Handle click-to-select for nodes (single click = select, double click = edit)
        if (State.clickedNode && !State.hasDragged) {
            const dx = Math.abs(e.clientX - State.clickStartPos.x);
            const dy = Math.abs(e.clientY - State.clickStartPos.y);
            const duration = Date.now() - State.clickStartTime;

            // If it was a quick click without much movement, SELECT the node
            if (duration < 500 && dx < 10 && dy < 10 && !State.linkingNode) {
                selectNode(State.clickedNode);
            }
        }
        State.clickedNode = null;
        State.clickedNodeEl = null;

        endDragging();
        endPanning();
    });

    canvasWrapper.addEventListener('mousedown', (e) => {
        const isCanvasClick = e.target === canvasWrapper ||
                              e.target.id === 'canvasBg' ||
                              e.target === canvas ||
                              e.target === svg;

        if (isCanvasClick) {
            // Shift+click for rectangle selection
            if (e.shiftKey) {
                startRectangleSelection(e);
                return;
            }

            wasPanning = true;
            panMoved = false;
            startPanning(e);

            // Clear multi-selection when clicking canvas without shift
            if (State.selectedNodes.length > 0) {
                State.selectedNodes = [];
                document.querySelectorAll('.node.multi-selected').forEach(el => {
                    el.classList.remove('multi-selected');
                });
                updateSelectionToolbar();
            }
        }
    });

    // Double click on canvas to create new note
    canvasWrapper.addEventListener('dblclick', (e) => {
        const isCanvasClick = e.target === canvasWrapper ||
                              e.target.id === 'canvasBg' ||
                              e.target === canvas ||
                              e.target === svg;

        if (isCanvasClick) {
            handleCanvasClick(e);
        }
    });

    canvasWrapper.addEventListener('wheel', handleWheelZoom);

    document.addEventListener('click', (e) => {
        if (!e.target.closest('.color-picker') && !e.target.closest('.node-color-btn')) {
            document.querySelectorAll('.color-picker.open').forEach(p => p.classList.remove('open'));
        }
    });
}

function initKeyboardEvents() {
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            cancelLinking();
            closeNodeModal();
            closeTopicModal();
            closeSubtopicModal();
            closeSyncModal();
            closeDetail();
            clearSelection();
            hideMoveMenu();
            // End flashcard session on escape
            if (State.flashcardSession.active) {
                endFlashcardSession();
            }
        }

        // Flashcard review keyboard shortcuts
        if (State.flashcardSession.active && State.currentView === 'flashcards') {
            if (e.code === 'Space' && !State.flashcardSession.showAnswer) {
                e.preventDefault();
                showFlashcardAnswer();
                return;
            }
            if (State.flashcardSession.showAnswer) {
                if (e.key === '1') { e.preventDefault(); rateFlashcard(1); return; }
                if (e.key === '2') { e.preventDefault(); rateFlashcard(2); return; }
                if (e.key === '3') { e.preventDefault(); rateFlashcard(3); return; }
                if (e.key === '4') { e.preventDefault(); rateFlashcard(4); return; }
            }
        }

        const modalOpen = $('nodeModal').classList.contains('visible');
        const detailOpen = $('detailPanel').classList.contains('open');
        const isEditing = document.activeElement.tagName === 'INPUT' ||
                          document.activeElement.tagName === 'TEXTAREA' ||
                          document.activeElement.isContentEditable;

        // Undo/Redo for detail panel (but allow native undo in textareas/inputs)
        if ((e.ctrlKey || e.metaKey) && detailOpen && !modalOpen && !isEditing) {
            if (e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
                return;
            }
            if ((e.key === 'z' && e.shiftKey) || e.key === 'y') {
                e.preventDefault();
                redo();
                return;
            }
        }

        // Double-press Delete/Backspace to delete (safety measure)
        // Only when not in modal and not editing text
        if ((e.key === 'Delete' || e.key === 'Backspace') && !modalOpen && !isEditing) {
            e.preventDefault();
            const now = Date.now();
            if (State.lastDeletePress && (now - State.lastDeletePress) < 500) {
                // Second press within 500ms - delete
                if (State.selectedNodes.length > 0) {
                    deleteSelectedNodes();
                } else if (State.selectedLink) {
                    deleteSelectedLink();
                } else if (State.selectedNode) {
                    deleteSelectedNode();
                }
                State.lastDeletePress = null;
            } else {
                // First press - show hint
                State.lastDeletePress = now;
                if (State.selectedNodes.length > 0 || State.selectedNode || State.selectedLink) {
                    showToast('Press Delete again to confirm');
                }
            }
        }

        // Copy/Paste notes with Cmd+C / Cmd+V, Select All with Cmd+A
        if ((e.metaKey || e.ctrlKey) && !modalOpen && !isEditing) {
            if (e.key === 'c') {
                e.preventDefault();
                copySelectedNotes();
            } else if (e.key === 'v') {
                e.preventDefault();
                pasteNotes();
            } else if (e.key === 'a' && State.currentSubtopic) {
                e.preventDefault();
                selectAllNodes();
            }
        }

        if (modalOpen) {
            const textarea = $('nodeContent');
            const titleInput = $('nodeTitle');

            if (document.activeElement === textarea || document.activeElement === titleInput) {
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z' || e.key === 'y') return;

                    if (e.key === 'b' && document.activeElement === textarea) {
                        e.preventDefault();
                        insertFormat('**', '**');
                    }

                    if (e.key === 'i' && document.activeElement === textarea) {
                        e.preventDefault();
                        insertFormat('*', '*');
                    }
                }
            }
        }
    });
}

document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
